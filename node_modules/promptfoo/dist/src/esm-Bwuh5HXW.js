#!/usr/bin/env node
import { o as logger_default } from "./logger-Bzi5o47S.js";
import { createRequire } from "node:module";
import { fileURLToPath, pathToFileURL } from "node:url";
import fs from "node:fs";
import path from "node:path";
import path$1 from "path";
import fsPromises from "node:fs/promises";
import vm from "node:vm";
import { resolveModulePath } from "exsolve";

//#region node_modules/tsdown/esm-shims.js
const getFilename = () => fileURLToPath(import.meta.url);
const getDirname = () => path.dirname(getFilename());
const __dirname = /* @__PURE__ */ getDirname();

//#endregion
//#region src/util/pathUtils.ts
/**
* Path resolution utilities that work with both regular paths and file:// URLs
*/
/**
* Check if a file path is absolute, handling both regular paths and URLs
* @param filePath - The file path to check
* @returns True if the path is absolute
*/
function isAbsolute$1(filePath) {
	if (!filePath) return false;
	if (/^[a-zA-Z][a-zA-Z\d+\-.]*:\/\//.test(filePath)) {
		if (filePath.startsWith("file://")) try {
			return path$1.isAbsolute(fileURLToPath(filePath));
		} catch {
			return true;
		}
		return true;
	}
	return path$1.isAbsolute(filePath);
}
/**
* Safely resolves a path - only calls resolve() if the last path is relative
* Leaves absolute paths and absolute URLs unchanged
*
* @param paths - The path segments to resolve
* @returns The resolved path if last path is relative, or the last path if it's absolute
*/
function safeResolve(...paths) {
	const lastPath = paths[paths.length - 1] || "";
	if (isAbsolute$1(lastPath)) return lastPath;
	return path$1.resolve(...paths);
}
/**
* Safely joins paths - only joins if the last path is relative
* If the last path is absolute or an absolute URL, returns it directly
*
* @param paths - The path segments to join
* @returns The joined path if last path is relative, or the last path if it's absolute
*/
function safeJoin(...paths) {
	const lastPath = paths[paths.length - 1] || "";
	if (isAbsolute$1(lastPath)) return lastPath;
	return path$1.join(...paths);
}

//#endregion
//#region src/esm.ts
/**
* Mapping of wrapper types to their subdirectory names.
* These correspond to the directory structure under src/ and dist/src/.
*/
const WRAPPER_SUBDIRS = {
	python: "python",
	ruby: "ruby",
	golang: "golang"
};
/**
* Cache for wrapper directory paths to avoid repeated path construction.
*/
const wrapperDirCache = {};
/**
* Returns the directory containing wrapper scripts for the specified language.
*
* This function provides a consistent way to locate wrapper scripts (wrapper.py,
* wrapper.rb, wrapper.go, etc.) that works correctly in both development and
* production (bundled) environments.
*
* Directory resolution:
* - Development (tsx): src/{python|ruby|golang}/
* - Production (bundled): dist/src/{python|ruby|golang}/
*
* Results are cached for performance.
*
* @param type - The wrapper type ('python', 'ruby', or 'golang')
* @returns The absolute path to the wrapper directory
*
* @example
* ```typescript
* // Get Python wrapper path
* const pythonDir = getWrapperDir('python');
* const wrapperPath = path.join(pythonDir, 'wrapper.py');
*
* // Get Ruby wrapper path
* const rubyDir = getWrapperDir('ruby');
* const wrapperPath = path.join(rubyDir, 'wrapper.rb');
* ```
*/
function getWrapperDir(type) {
	if (wrapperDirCache[type]) return wrapperDirCache[type];
	const baseDir = getDirectory();
	const result = path.join(baseDir, WRAPPER_SUBDIRS[type]);
	wrapperDirCache[type] = result;
	logger_default.debug(`Resolved ${type} wrapper directory: ${result}`);
	return result;
}
/**
* Resolves the entry point path for an npm package, handling ESM-only packages
* with restrictive `exports` fields.
*
* ## Why this function exists
*
* Some ESM-only packages (like `@openai/codex-sdk`) have restrictive `exports` fields:
*
* ```json
* {
*   "type": "module",
*   "exports": {
*     ".": { "import": "./dist/index.js" }
*   }
* }
* ```
*
* This causes problems with Node.js's `require.resolve()`:
* - `require.resolve('@openai/codex-sdk')` fails with "No exports main defined"
*   because there's no `"require"` or `"default"` condition.
*
* ## Solution
*
* This function uses `exsolve` which implements Node's ESM resolution algorithm,
* correctly handling all `exports` field variations:
* - Direct string exports: `"exports": "./index.js"`
* - Shorthand object: `"exports": { ".": "./index.js" }`
* - Conditional exports: `"exports": { ".": { "import": "./index.js" } }`
* - Nested conditionals, array fallbacks, pattern exports, etc.
*
* @param packageName - The npm package name (e.g., '@openai/codex-sdk')
* @param baseDir - The directory to resolve from (should contain node_modules)
* @returns The absolute path to the package entry point, or null if not found
*
* @example
* ```typescript
* // Resolve from current directory
* const codexPath = resolvePackageEntryPoint('@openai/codex-sdk', process.cwd());
* if (codexPath) {
*   const module = await importModule(codexPath);
* }
* ```
*/
function resolvePackageEntryPoint(packageName, baseDir) {
	const from = pathToFileURL(path.join(baseDir, "package.json")).href;
	const resolved = resolveModulePath(packageName, {
		from,
		conditions: [
			"node",
			"import",
			"require",
			"default"
		],
		try: true
	});
	return resolved ? path.normalize(resolved) : null;
}
/**
* ESM replacement for __dirname - guarded for dual CJS/ESM builds.
*
* This is the canonical way to get the current directory in dual ESM/CJS code.
* Use this instead of implementing the try-catch pattern in each file.
*
* Build contexts:
* - ESM (production/bundled): BUILD_FORMAT='esm', import.meta.url is valid
* - CJS (library build): BUILD_FORMAT='cjs', import.meta.url may be empty, __dirname available
* - Development (tsx): BUILD_FORMAT=undefined, import.meta.url is valid
* - Vitest tests: BUILD_FORMAT=undefined, import.meta is valid in ESM mode
*
* The try-catch is necessary because `import.meta` syntax itself causes a SyntaxError
* in CJS environments (Node require), not just an undefined value.
*/
function getDirectory() {
	try {
		const url = import.meta.url;
		if (url && url !== "") return path.dirname(fileURLToPath(url));
	} catch {}
	if (typeof __dirname !== "undefined") return __dirname;
	throw new Error("Unable to determine directory: neither import.meta.url nor __dirname available. This indicates an unsupported module environment.");
}
/**
* ESM-only module loader - simplified without eval() or CommonJS fallback
* Uses Node.js native ESM import with proper URL resolution
*/
async function importModule(modulePath, functionName) {
	logger_default.debug(`Attempting to import module: ${JSON.stringify({
		resolvedPath: safeResolve(modulePath),
		moduleId: modulePath
	})}`);
	try {
		if (modulePath.endsWith(".ts") || modulePath.endsWith(".mjs")) {
			logger_default.debug("TypeScript/ESM module detected, importing tsx/cjs");
			await import("tsx/cjs");
		}
		const resolvedPath = pathToFileURL(safeResolve(modulePath));
		const resolvedPathStr = resolvedPath.toString();
		logger_default.debug(`Attempting ESM import from: ${resolvedPathStr}`);
		const importedModule = await import(resolvedPathStr);
		const mod = importedModule?.default?.default || importedModule?.default || importedModule;
		logger_default.debug(`Successfully imported module: ${JSON.stringify({
			resolvedPath,
			moduleId: modulePath
		})}`);
		if (functionName) {
			logger_default.debug(`Returning named export: ${functionName}`);
			return mod[functionName];
		}
		return mod;
	} catch (err) {
		const errorMessage = err instanceof Error ? err.message : String(err);
		if (modulePath.endsWith(".js") && isCjsInEsmError(errorMessage)) {
			logger_default.debug(`ESM import failed for ${modulePath}, attempting vm-based CJS fallback: ${errorMessage}`);
			try {
				const resolvedPath = safeResolve(modulePath);
				const mod = loadCjsModule(resolvedPath);
				logger_default.debug(`Successfully loaded module via CJS fallback: ${JSON.stringify({
					resolvedPath,
					moduleId: modulePath
				})}`);
				if (functionName) {
					logger_default.debug(`Returning named export: ${functionName}`);
					return mod[functionName];
				}
				return mod;
			} catch (cjsErr) {
				const cjsErrorMessage = cjsErr instanceof Error ? cjsErr.message : String(cjsErr);
				logger_default.error(`ESM import failed for ${modulePath}: ${errorMessage}`);
				logger_default.error(`CJS fallback also failed: ${cjsErrorMessage}`);
				const combinedError = /* @__PURE__ */ new Error(`Failed to load module ${modulePath}:\n  ESM import error: ${errorMessage}\n  CJS fallback error: ${cjsErrorMessage}\nTo fix this, either:\n  1. Rename the file to .cjs (recommended for CommonJS)\n  2. Convert to ESM syntax (import/export)\n  3. Ensure the file has valid JavaScript syntax`);
				combinedError.cause = {
					esmError: err,
					cjsError: cjsErr
				};
				throw combinedError;
			}
		}
		const e = err;
		if (e.stack) logger_default.debug(e.stack);
		if (err.code === "ERR_MODULE_NOT_FOUND") {
			const resolvedModulePath = safeResolve(modulePath);
			try {
				await fsPromises.access(resolvedModulePath);
				logger_default.error(`ESM import failed: ${err}`);
			} catch {
				const enoentError = /* @__PURE__ */ new Error(`ENOENT: no such file or directory, open '${resolvedModulePath}'`);
				enoentError.code = "ENOENT";
				enoentError.path = resolvedModulePath;
				throw enoentError;
			}
		} else logger_default.error(`ESM import failed: ${err}`);
		throw err;
	}
}
/**
* Detects if an error message indicates a CommonJS module being loaded in ESM context.
*/
function isCjsInEsmError(message) {
	return [
		"require is not defined",
		"module is not defined",
		"exports is not defined",
		"__dirname is not defined",
		"__filename is not defined",
		"Cannot use import statement",
		"ERR_REQUIRE_ESM"
	].some((pattern) => message.includes(pattern));
}
/**
* Loads a CommonJS module by executing it in a vm context with proper CJS globals.
* This bypasses Node.js's module type detection which is based on package.json "type" field.
*
* SECURITY NOTE: This is NOT a security sandbox. The executed code has full access to
* the file system, network, etc. via the injected require function and process object.
* This is intentional - it's designed for loading trusted user configuration files
* (custom providers, assertions, hooks) that need full Node.js capabilities.
*/
function loadCjsModule(modulePath) {
	const code = fs.readFileSync(modulePath, "utf-8");
	const dirname = path.dirname(modulePath);
	const filename = modulePath;
	const moduleRequire = createRequire(pathToFileURL(modulePath).href);
	const moduleObj = { exports: {} };
	const context = vm.createContext({
		module: moduleObj,
		exports: moduleObj.exports,
		require: moduleRequire,
		__dirname: dirname,
		__filename: filename,
		global: globalThis,
		globalThis,
		console,
		process,
		Buffer,
		setTimeout,
		setInterval,
		setImmediate,
		clearTimeout,
		clearInterval,
		clearImmediate,
		queueMicrotask,
		URL,
		URLSearchParams,
		TextEncoder,
		TextDecoder,
		atob: globalThis.atob,
		btoa: globalThis.btoa,
		fetch: globalThis.fetch,
		Request: globalThis.Request,
		Response: globalThis.Response,
		Headers: globalThis.Headers,
		AbortController: globalThis.AbortController,
		AbortSignal: globalThis.AbortSignal,
		Event: globalThis.Event,
		EventTarget: globalThis.EventTarget,
		Error,
		TypeError,
		ReferenceError,
		SyntaxError,
		RangeError,
		Array,
		Object,
		String,
		Number,
		Boolean,
		Symbol,
		Map,
		Set,
		WeakMap,
		WeakSet,
		Promise,
		Proxy,
		Reflect,
		JSON,
		Math,
		Date,
		RegExp,
		Int8Array,
		Uint8Array,
		Uint8ClampedArray,
		Int16Array,
		Uint16Array,
		Int32Array,
		Uint32Array,
		Float32Array,
		Float64Array,
		BigInt64Array,
		BigUint64Array,
		DataView,
		ArrayBuffer,
		SharedArrayBuffer: globalThis.SharedArrayBuffer,
		Atomics: globalThis.Atomics,
		BigInt,
		eval: void 0,
		Function,
		isNaN,
		isFinite,
		parseFloat,
		parseInt,
		decodeURI,
		decodeURIComponent,
		encodeURI,
		encodeURIComponent
	});
	vm.runInContext(code, context, { filename: modulePath });
	return moduleObj.exports;
}

//#endregion
export { safeJoin as a, resolvePackageEntryPoint as i, getWrapperDir as n, safeResolve as o, importModule as r, getDirectory as t };
//# sourceMappingURL=esm-Bwuh5HXW.js.map