import { C as isCI, _ as getEnvBool, b as getEnvString, i as logger_default } from "./logger-q5I8CByj.js";
import { F as VERSION, O as EVENTS_ENDPOINT, P as POSTHOG_KEY, T as CONSENT_ENDPOINT, k as R_ENDPOINT, r as fetchWithTimeout, t as fetchWithProxy } from "./fetch-BIPrzD39.js";
import { a as getUserId, i as getUserEmail, n as getAuthMethod, o as isLoggedIntoCloud } from "./accounts-DYMHC4iY.js";
import { z } from "zod";
import { PostHog } from "posthog-node";

//#region src/telemetry.ts
const TelemetryEventSchema = z.object({
	event: z.enum([
		"assertion_used",
		"command_used",
		"eval_ran",
		"feature_used",
		"funnel",
		"redteam discover",
		"redteam generate",
		"redteam init",
		"redteam poison",
		"redteam report",
		"redteam run",
		"redteam setup",
		"webui_action",
		"webui_api",
		"webui_page_view"
	]),
	packageVersion: z.string().optional().prefault(VERSION),
	properties: z.record(z.string(), z.union([
		z.string(),
		z.number(),
		z.boolean(),
		z.array(z.string())
	]))
});
let posthogClient = null;
let isShuttingDown = false;
function getPostHogClient() {
	if (getEnvBool("PROMPTFOO_DISABLE_TELEMETRY") || getEnvBool("IS_TESTING")) return null;
	if (posthogClient === null && POSTHOG_KEY) try {
		posthogClient = new PostHog(POSTHOG_KEY, {
			host: EVENTS_ENDPOINT,
			fetch: fetchWithProxy,
			flushInterval: 0
		});
	} catch {
		posthogClient = null;
	}
	return posthogClient;
}
const TELEMETRY_TIMEOUT_MS = 1e3;
var Telemetry = class {
	telemetryDisabledRecorded = false;
	id;
	email;
	constructor() {
		this.id = getUserId();
		this.email = getUserEmail();
		this.identify();
	}
	async identify() {
		if (this.disabled || getEnvBool("IS_TESTING")) return;
		const client = getPostHogClient();
		if (client) try {
			client.identify({
				distinctId: this.id,
				properties: {
					email: this.email,
					isLoggedIntoCloud: isLoggedIntoCloud(),
					authMethod: getAuthMethod(),
					isRunningInCi: isCI()
				}
			});
			client.flush().catch(() => {});
		} catch (error) {
			logger_default.debug(`PostHog identify error: ${error}`);
		}
	}
	get disabled() {
		return getEnvBool("PROMPTFOO_DISABLE_TELEMETRY");
	}
	recordTelemetryDisabled() {
		if (!this.telemetryDisabledRecorded) {
			this.sendEvent("feature_used", { feature: "telemetry disabled" });
			this.telemetryDisabledRecorded = true;
		}
	}
	record(eventName, properties) {
		if (this.disabled) this.recordTelemetryDisabled();
		else this.sendEvent(eventName, properties);
	}
	sendEvent(eventName, properties) {
		const propertiesWithMetadata = {
			...properties,
			packageVersion: VERSION,
			isRunningInCi: isCI()
		};
		const client = getPostHogClient();
		if (client && !getEnvBool("IS_TESTING")) try {
			client.capture({
				distinctId: this.id,
				event: eventName,
				properties: propertiesWithMetadata
			});
			client.flush().catch(() => {});
		} catch (error) {
			logger_default.debug(`PostHog capture error: ${error}`);
		}
		fetchWithProxy(R_ENDPOINT, {
			method: "POST",
			headers: { "Content-Type": "application/json" },
			body: JSON.stringify({
				event: eventName,
				environment: getEnvString("NODE_ENV", "development"),
				email: this.email,
				meta: {
					user_id: this.id,
					...propertiesWithMetadata
				}
			})
		}).catch(() => {});
	}
	async shutdown() {
		if (isShuttingDown) return;
		const client = getPostHogClient();
		if (!client) return;
		isShuttingDown = true;
		try {
			await client.shutdown();
		} catch (error) {
			logger_default.debug(`PostHog shutdown error: ${error}`);
		}
	}
	/**
	* This is a separate endpoint to save consent used only for redteam data synthesis for "harmful" plugins.
	*/
	async saveConsent(email, metadata) {
		try {
			const response = await fetchWithTimeout(CONSENT_ENDPOINT, {
				method: "POST",
				headers: { "Content-Type": "application/json" },
				body: JSON.stringify({
					email,
					metadata
				})
			}, TELEMETRY_TIMEOUT_MS);
			if (!response.ok) throw new Error(`Failed to save consent: ${response.statusText}`);
		} catch (err) {
			logger_default.debug(`Failed to save consent: ${err.message}`);
		}
	}
};
const telemetry = new Telemetry();
const TELEMETRY_INSTANCE_KEY = Symbol.for("promptfoo.telemetry.instance");
const SHUTDOWN_HANDLER_KEY = Symbol.for("promptfoo.telemetry.shutdownHandler");
process[TELEMETRY_INSTANCE_KEY] = telemetry;
if (!process[SHUTDOWN_HANDLER_KEY]) {
	process[SHUTDOWN_HANDLER_KEY] = true;
	process.once("beforeExit", () => {
		const instance = process[TELEMETRY_INSTANCE_KEY];
		if (instance) instance.shutdown().catch(() => {});
	});
}
var telemetry_default = telemetry;

//#endregion
export { telemetry_default as n, Telemetry as t };
//# sourceMappingURL=telemetry-CmGyDaxF.js.map