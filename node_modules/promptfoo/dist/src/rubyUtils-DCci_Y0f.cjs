const require_logger = require('./logger-CMp-NS-e.cjs');
const require_esm = require('./esm-gWVPXn3r.cjs');
let fs = require("fs");
fs = require_logger.__toESM(fs);
let path = require("path");
path = require_logger.__toESM(path);
let os = require("os");
os = require_logger.__toESM(os);
let child_process = require("child_process");
let util = require("util");

//#region src/ruby/rubyUtils.ts
const execFileAsync = (0, util.promisify)(child_process.execFile);
/**
* Global state for Ruby executable path caching.
* Ensures consistent Ruby executable usage across multiple provider instances.
*/
const state = {
	cachedRubyPath: null,
	validationPromise: null,
	validatingPath: null
};
/**
* Attempts to find Ruby using Windows 'where' command.
* Only applicable on Windows platforms.
* @returns The validated Ruby executable path, or null if not found
*/
async function tryWindowsWhere() {
	try {
		const output = (await execFileAsync("where", ["ruby"])).stdout.trim();
		if (!output) {
			require_logger.logger_default.debug("Windows 'where ruby' returned empty output");
			return null;
		}
		const paths = output.split("\n").filter((path) => path.trim());
		for (const rubyPath of paths) {
			const trimmedPath = rubyPath.trim();
			if (!trimmedPath.endsWith(".exe")) continue;
			const validated = await tryPath(trimmedPath);
			if (validated) return validated;
		}
	} catch (error) {
		const errorMsg = error instanceof Error ? error.message : String(error);
		require_logger.logger_default.debug(`Windows 'where ruby' failed: ${errorMsg}`);
		if (errorMsg.includes("Access is denied") || errorMsg.includes("EACCES")) require_logger.logger_default.warn(`Permission denied when searching for Ruby: ${errorMsg}`);
	}
	return null;
}
/**
* Attempts to get Ruby executable path by running Ruby commands.
* Uses RbConfig.ruby to get the actual Ruby executable path.
* @param commands - Array of Ruby command names to try (e.g., ['ruby'])
* @returns The Ruby executable path, or null if all commands fail
*/
async function tryRubyCommands(commands) {
	for (const cmd of commands) try {
		const executablePath = (await execFileAsync(cmd, ["-e", "puts RbConfig.ruby"])).stdout.trim();
		if (executablePath && executablePath !== "None") return executablePath;
	} catch (error) {
		const errorMsg = error instanceof Error ? error.message : String(error);
		require_logger.logger_default.debug(`Ruby command "${cmd}" failed: ${errorMsg}`);
		if (errorMsg.includes("Access is denied") || errorMsg.includes("EACCES") || errorMsg.includes("EPERM")) require_logger.logger_default.warn(`Permission denied when trying Ruby command "${cmd}": ${errorMsg}`);
	}
	return null;
}
/**
* Attempts to validate Ruby commands directly as a final fallback.
* Validates each command by running it with --version.
* @param commands - Array of Ruby command names to try (e.g., ['ruby'])
* @returns The validated Ruby executable path, or null if all commands fail
*/
async function tryDirectCommands(commands) {
	for (const cmd of commands) try {
		const validated = await tryPath(cmd);
		if (validated) return validated;
	} catch (error) {
		const errorMsg = error instanceof Error ? error.message : String(error);
		require_logger.logger_default.debug(`Direct command "${cmd}" failed: ${errorMsg}`);
		if (errorMsg.includes("Access is denied") || errorMsg.includes("EACCES") || errorMsg.includes("EPERM")) require_logger.logger_default.warn(`Permission denied when trying Ruby command "${cmd}": ${errorMsg}`);
	}
	return null;
}
/**
* Attempts to get the Ruby executable path using platform-appropriate strategies.
* @returns The Ruby executable path if successful, or null if failed.
*/
async function getSysExecutable() {
	if (process.platform === "win32") {
		const whereResult = await tryWindowsWhere();
		if (whereResult) return whereResult;
		const sysResult = await tryRubyCommands(["ruby"]);
		if (sysResult) return sysResult;
		return await tryDirectCommands(["ruby"]);
	} else return await tryRubyCommands(["ruby"]);
}
/**
* Attempts to validate a Ruby executable path.
* @param path - The path to the Ruby executable to test.
* @returns The validated path if successful, or null if invalid.
*/
async function tryPath(path) {
	let timeoutId;
	try {
		const timeoutPromise = new Promise((_, reject) => {
			timeoutId = setTimeout(() => reject(/* @__PURE__ */ new Error("Command timed out")), 2500);
		});
		const result = await Promise.race([execFileAsync(path, ["--version"]), timeoutPromise]);
		if (timeoutId) clearTimeout(timeoutId);
		if (result.stdout.trim().toLowerCase().includes("ruby")) return path;
		return null;
	} catch {
		if (timeoutId) clearTimeout(timeoutId);
		return null;
	}
}
/**
* Validates and caches the Ruby executable path.
*
* @param rubyPath - Path to the Ruby executable.
* @param isExplicit - If true, only tries the provided path.
* @returns Validated Ruby executable path.
* @throws {Error} If no valid Ruby executable is found.
*/
async function validateRubyPath(rubyPath, isExplicit) {
	if (state.cachedRubyPath && state.validatingPath === rubyPath) return state.cachedRubyPath;
	if (state.validatingPath !== rubyPath) {
		state.cachedRubyPath = null;
		state.validationPromise = null;
		state.validatingPath = rubyPath;
	}
	if (!state.validationPromise) state.validationPromise = (async () => {
		try {
			const primaryPath = await tryPath(rubyPath);
			if (primaryPath) {
				state.cachedRubyPath = primaryPath;
				state.validationPromise = null;
				return primaryPath;
			}
			if (isExplicit) {
				const error = /* @__PURE__ */ new Error(`Ruby not found. Tried "${rubyPath}" Please ensure Ruby is installed and set the PROMPTFOO_RUBY environment variable to your Ruby executable path (e.g., '${process.platform === "win32" ? "C:\\Ruby32\\bin\\ruby.exe" : "/usr/bin/ruby"}').`);
				state.validationPromise = null;
				throw error;
			}
			const detectedPath = await getSysExecutable();
			if (detectedPath) {
				state.cachedRubyPath = detectedPath;
				state.validationPromise = null;
				return detectedPath;
			}
			const error = /* @__PURE__ */ new Error(`Ruby not found. Tried "${rubyPath}", ruby executable detection, and fallback commands. Please ensure Ruby is installed and set the PROMPTFOO_RUBY environment variable to your Ruby executable path (e.g., '${process.platform === "win32" ? "C:\\Ruby32\\bin\\ruby.exe" : "/usr/bin/ruby"}').`);
			state.validationPromise = null;
			throw error;
		} catch (error) {
			state.validationPromise = null;
			throw error;
		}
	})();
	return state.validationPromise;
}
/**
* Runs a Ruby script with the specified method and arguments.
*
* @param scriptPath - The path to the Ruby script to run.
* @param method - The name of the method to call in the Ruby script.
* @param args - An array of arguments to pass to the Ruby script.
* @param options - Optional settings for running the Ruby script.
* @param options.rubyExecutable - Optional path to the Ruby executable.
* @returns A promise that resolves to the output of the Ruby script.
* @throws An error if there's an issue running the Ruby script or parsing its output.
*/
async function runRuby(scriptPath, method, args, options = {}) {
	const absPath = path.default.resolve(scriptPath);
	const tempJsonPath = path.default.join(os.default.tmpdir(), `promptfoo-ruby-input-json-${Date.now()}-${Math.random().toString(16).slice(2)}.json`);
	const outputPath = path.default.join(os.default.tmpdir(), `promptfoo-ruby-output-json-${Date.now()}-${Math.random().toString(16).slice(2)}.json`);
	const customPath = options.rubyExecutable || require_logger.getEnvString("PROMPTFOO_RUBY");
	let rubyPath = customPath || "ruby";
	rubyPath = await validateRubyPath(rubyPath, typeof customPath === "string");
	const wrapperPath = path.default.join(require_esm.getWrapperDir("ruby"), "wrapper.rb");
	try {
		fs.default.writeFileSync(tempJsonPath, require_logger.safeJsonStringify(args), "utf-8");
		require_logger.logger_default.debug(`Running Ruby wrapper with args: ${require_logger.safeJsonStringify(args)}`);
		const { stdout, stderr } = await execFileAsync(rubyPath, [
			wrapperPath,
			absPath,
			method,
			tempJsonPath,
			outputPath
		]);
		if (stdout) require_logger.logger_default.debug(stdout.trim());
		if (stderr) require_logger.logger_default.error(stderr.trim());
		const output = fs.default.readFileSync(outputPath, "utf-8");
		require_logger.logger_default.debug(`Ruby script ${absPath} returned: ${output}`);
		let result;
		try {
			result = JSON.parse(output);
			require_logger.logger_default.debug(`Ruby script ${absPath} parsed output type: ${typeof result}, structure: ${result ? JSON.stringify(Object.keys(result)) : "undefined"}`);
		} catch (error) {
			throw new Error(`Invalid JSON: ${error.message} when parsing result: ${output}\nStack Trace: ${error.stack}`);
		}
		if (result?.type !== "final_result") throw new Error("The Ruby script `call_api` function must return a hash with an `output`");
		return result.data;
	} catch (error) {
		require_logger.logger_default.error(`Error running Ruby script: ${error.message}\nStack Trace: ${error.stack || "No Ruby traceback available"}`);
		throw new Error(`Error running Ruby script: ${error.message}\nStack Trace: ${error.stack || "No Ruby traceback available"}`);
	} finally {
		[tempJsonPath, outputPath].forEach((file) => {
			try {
				fs.default.unlinkSync(file);
			} catch (error) {
				require_logger.logger_default.error(`Error removing ${file}: ${error}`);
			}
		});
	}
}

//#endregion
Object.defineProperty(exports, 'getSysExecutable', {
  enumerable: true,
  get: function () {
    return getSysExecutable;
  }
});
Object.defineProperty(exports, 'runRuby', {
  enumerable: true,
  get: function () {
    return runRuby;
  }
});
Object.defineProperty(exports, 'state', {
  enumerable: true,
  get: function () {
    return state;
  }
});
Object.defineProperty(exports, 'tryPath', {
  enumerable: true,
  get: function () {
    return tryPath;
  }
});
Object.defineProperty(exports, 'validateRubyPath', {
  enumerable: true,
  get: function () {
    return validateRubyPath;
  }
});
//# sourceMappingURL=rubyUtils-DCci_Y0f.cjs.map