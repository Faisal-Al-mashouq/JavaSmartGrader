const require_logger = require('./logger-CMp-NS-e.cjs');
const require_util = require('./util-BNInkV3p.cjs');
const require_cache = require('./cache-DH-n6i0J.cjs');
const require_genaiTracer = require('./genaiTracer-zK0Mtd_D.cjs');
const require_chat = require('./chat-CAz560qk.cjs');
const require_tokenUsageUtils = require('./tokenUsageUtils-DFp2VFtG.cjs');
const require_transform = require('./transform-CGHhgwFQ.cjs');
const require_util$1 = require('./util-YP1N9HUu.cjs');
let _anthropic_ai_sdk = require("@anthropic-ai/sdk");
_anthropic_ai_sdk = require_logger.__toESM(_anthropic_ai_sdk);

//#region src/providers/anthropic/generic.ts
/**
* Generic provider class for Anthropic APIs
* Serves as a base class with shared functionality for all Anthropic providers
*/
var AnthropicGenericProvider = class {
	modelName;
	config;
	env;
	apiKey;
	anthropic;
	constructor(modelName, options = {}) {
		const { config, id, env } = options;
		this.env = env;
		this.modelName = modelName;
		this.config = config || {};
		this.apiKey = this.getApiKey();
		this.anthropic = new _anthropic_ai_sdk.default({
			apiKey: this.apiKey,
			baseURL: this.getApiBaseUrl()
		});
		this.id = id ? () => id : this.id;
	}
	id() {
		return `anthropic:${this.modelName}`;
	}
	toString() {
		return `[Anthropic Provider ${this.modelName}]`;
	}
	getApiKey() {
		return this.config?.apiKey || this.env?.ANTHROPIC_API_KEY || require_logger.getEnvString("ANTHROPIC_API_KEY");
	}
	getApiBaseUrl() {
		return this.config?.apiBaseUrl || this.env?.ANTHROPIC_BASE_URL || require_logger.getEnvString("ANTHROPIC_BASE_URL");
	}
	/**
	* Base implementation - should be overridden by specific provider implementations
	*/
	async callApi(_prompt, _context) {
		throw new Error("Not implemented: callApi must be implemented by subclasses");
	}
};

//#endregion
//#region src/providers/anthropic/messages.ts
var AnthropicMessagesProvider = class AnthropicMessagesProvider extends AnthropicGenericProvider {
	mcpClient = null;
	initializationPromise = null;
	static ANTHROPIC_MODELS = require_util$1.ANTHROPIC_MODELS;
	static ANTHROPIC_MODELS_NAMES = require_util$1.ANTHROPIC_MODELS.map((model) => model.id);
	constructor(modelName, options = {}) {
		if (!AnthropicMessagesProvider.ANTHROPIC_MODELS_NAMES.includes(modelName)) require_logger.logger_default.warn(`Using unknown Anthropic model: ${modelName}`);
		super(modelName, options);
		const { id } = options;
		this.id = id ? () => id : this.id;
		if (this.config.mcp?.enabled) this.initializationPromise = this.initializeMCP();
	}
	async initializeMCP() {
		this.mcpClient = new require_chat.MCPClient(this.config.mcp);
		await this.mcpClient.initialize();
	}
	async cleanup() {
		if (this.mcpClient) {
			await this.initializationPromise;
			await this.mcpClient.cleanup();
			this.mcpClient = null;
		}
	}
	toString() {
		if (!this.modelName) throw new Error("Anthropic model name is not set. Please provide a valid model name.");
		return `[Anthropic Messages Provider ${this.modelName}]`;
	}
	async callApi(prompt, context) {
		if (this.initializationPromise != null) await this.initializationPromise;
		if (!this.apiKey) throw new Error("Anthropic API key is not set. Set the ANTHROPIC_API_KEY environment variable or add `apiKey` to the provider config.");
		if (!this.modelName) throw new Error("Anthropic model name is not set. Please provide a valid model name.");
		const spanContext = {
			system: "anthropic",
			operationName: "chat",
			model: this.modelName,
			providerId: this.id(),
			maxTokens: this.config.max_tokens,
			temperature: this.config.temperature,
			testIndex: context?.test?.vars?.__testIdx,
			promptLabel: context?.prompt?.label,
			traceparent: context?.traceparent,
			requestBody: prompt
		};
		const resultExtractor = (response) => {
			const result = {};
			if (response.tokenUsage) result.tokenUsage = {
				prompt: response.tokenUsage.prompt,
				completion: response.tokenUsage.completion,
				total: response.tokenUsage.total,
				cached: response.tokenUsage.cached
			};
			if (response.finishReason) result.finishReasons = [response.finishReason];
			if (response.cached !== void 0) result.cacheHit = response.cached;
			if (response.output !== void 0) result.responseBody = typeof response.output === "string" ? response.output : JSON.stringify(response.output);
			return result;
		};
		return require_genaiTracer.withGenAISpan(spanContext, () => this.callApiInternal(prompt, context), resultExtractor);
	}
	/**
	* Internal implementation of callApi without tracing wrapper.
	*/
	async callApiInternal(prompt, context) {
		const config = {
			...this.config,
			...context?.prompt?.config
		};
		const { system, extractedMessages, thinking } = require_util$1.parseMessages(prompt);
		let mcpTools = [];
		if (this.mcpClient) mcpTools = require_transform.transformMCPToolsToAnthropic(this.mcpClient.getAllTools());
		const { processedTools: processedConfigTools, requiredBetaFeatures } = require_util$1.processAnthropicTools(await require_util.maybeLoadToolsFromExternalFile(config.tools, context?.vars) || []);
		const allTools = [...mcpTools, ...processedConfigTools];
		const processedOutputFormat = require_util.maybeLoadResponseFormatFromExternalFile(config.output_format, context?.vars);
		const shouldStream = config.stream ?? false;
		const params = {
			model: this.modelName,
			...system ? { system } : {},
			max_tokens: config?.max_tokens || require_logger.getEnvInt("ANTHROPIC_MAX_TOKENS", config.thinking || thinking ? 2048 : 1024),
			messages: extractedMessages,
			stream: shouldStream,
			temperature: config.thinking || thinking ? config.temperature : config.temperature || require_logger.getEnvFloat("ANTHROPIC_TEMPERATURE", 0),
			...allTools.length > 0 ? { tools: allTools } : {},
			...config.tool_choice ? { tool_choice: config.tool_choice } : {},
			...config.thinking || thinking ? { thinking: config.thinking || thinking } : {},
			...processedOutputFormat ? { output_format: processedOutputFormat } : {},
			...typeof config?.extra_body === "object" && config.extra_body ? config.extra_body : {}
		};
		require_logger.logger_default.debug("Calling Anthropic Messages API", { params });
		const headers = { ...config.headers || {} };
		let allBetaFeatures = [...config.beta || [], ...requiredBetaFeatures];
		if (processedOutputFormat && !allBetaFeatures.includes("structured-outputs-2025-11-13")) allBetaFeatures.push("structured-outputs-2025-11-13");
		allBetaFeatures = [...new Set(allBetaFeatures)];
		if (allBetaFeatures.length > 0) headers["anthropic-beta"] = allBetaFeatures.join(",");
		const cache = await require_cache.getCache();
		const cacheKey = `anthropic:${JSON.stringify(params)}`;
		if (require_cache.isCacheEnabled()) {
			const cachedResponse = await cache.get(cacheKey);
			if (cachedResponse) {
				require_logger.logger_default.debug(`Returning cached response for ${prompt}: ${cachedResponse}`);
				try {
					const parsedCachedResponse = JSON.parse(cachedResponse);
					const finishReason = require_chat.normalizeFinishReason(parsedCachedResponse.stop_reason);
					let output = require_util$1.outputFromMessage(parsedCachedResponse, config.showThinking ?? true);
					if (processedOutputFormat?.type === "json_schema" && typeof output === "string") try {
						output = JSON.parse(output);
					} catch (error) {
						require_logger.logger_default.error(`Failed to parse JSON output from structured outputs: ${error}`);
					}
					return {
						output,
						tokenUsage: require_util$1.getTokenUsage(parsedCachedResponse, true),
						...finishReason && { finishReason },
						cost: require_util$1.calculateAnthropicCost(this.modelName, config, parsedCachedResponse.usage?.input_tokens, parsedCachedResponse.usage?.output_tokens),
						cached: true
					};
				} catch {
					return {
						output: cachedResponse,
						tokenUsage: require_tokenUsageUtils.createEmptyTokenUsage()
					};
				}
			}
		}
		try {
			if (shouldStream) {
				const finalMessage = await (await this.anthropic.messages.stream(params, { ...typeof headers === "object" && Object.keys(headers).length > 0 ? { headers } : {} })).finalMessage();
				require_logger.logger_default.debug(`Anthropic Messages API streaming complete`, { finalMessage });
				if (require_cache.isCacheEnabled()) try {
					await cache.set(cacheKey, JSON.stringify(finalMessage));
				} catch (err) {
					require_logger.logger_default.error(`Failed to cache response: ${String(err)}`);
				}
				const finishReason = require_chat.normalizeFinishReason(finalMessage.stop_reason);
				let output = require_util$1.outputFromMessage(finalMessage, config.showThinking ?? true);
				if (processedOutputFormat?.type === "json_schema" && typeof output === "string") try {
					output = JSON.parse(output);
				} catch (error) {
					require_logger.logger_default.error(`Failed to parse JSON output from structured outputs: ${error}`);
				}
				return {
					output,
					tokenUsage: require_util$1.getTokenUsage(finalMessage, false),
					...finishReason && { finishReason },
					cost: require_util$1.calculateAnthropicCost(this.modelName, config, finalMessage.usage?.input_tokens, finalMessage.usage?.output_tokens)
				};
			} else {
				const response = await this.anthropic.messages.create(params, { ...typeof headers === "object" && Object.keys(headers).length > 0 ? { headers } : {} });
				require_logger.logger_default.debug(`Anthropic Messages API response`, { response });
				if (require_cache.isCacheEnabled()) try {
					await cache.set(cacheKey, JSON.stringify(response));
				} catch (err) {
					require_logger.logger_default.error(`Failed to cache response: ${String(err)}`);
				}
				const finishReason = require_chat.normalizeFinishReason(response.stop_reason);
				let output = require_util$1.outputFromMessage(response, config.showThinking ?? true);
				if (processedOutputFormat?.type === "json_schema" && typeof output === "string") try {
					output = JSON.parse(output);
				} catch (error) {
					require_logger.logger_default.error(`Failed to parse JSON output from structured outputs: ${error}`);
				}
				return {
					output,
					tokenUsage: require_util$1.getTokenUsage(response, false),
					...finishReason && { finishReason },
					cost: require_util$1.calculateAnthropicCost(this.modelName, config, response.usage?.input_tokens, response.usage?.output_tokens)
				};
			}
		} catch (err) {
			require_logger.logger_default.error(`Anthropic Messages API call error: ${err instanceof Error ? err.message : String(err)}`);
			if (err instanceof _anthropic_ai_sdk.APIError && err.error) {
				const errorDetails = err.error;
				return { error: `API call error: ${errorDetails.error.message}, status ${err.status}, type ${errorDetails.error.type}` };
			}
			return { error: `API call error: ${err instanceof Error ? err.message : String(err)}` };
		}
	}
};

//#endregion
Object.defineProperty(exports, 'AnthropicGenericProvider', {
  enumerable: true,
  get: function () {
    return AnthropicGenericProvider;
  }
});
Object.defineProperty(exports, 'AnthropicMessagesProvider', {
  enumerable: true,
  get: function () {
    return AnthropicMessagesProvider;
  }
});
//# sourceMappingURL=messages-BbRLnkcl.cjs.map