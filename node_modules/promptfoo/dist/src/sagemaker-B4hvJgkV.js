#!/usr/bin/env node
import "./chunk-DHDDz29n.js";
import { C as getEnvString, S as getEnvInt, o as logger_default, x as getEnvFloat } from "./logger-Bzi5o47S.js";
import "./fetch-TcCC0nEJ.js";
import "./accounts-CjU7QSnv.js";
import "./cloud-UwfmA0Ne.js";
import { r as telemetry_default } from "./telemetry-CB8ltkOD.js";
import "./esm-Bwuh5HXW.js";
import "./pythonUtils-mprm8p4h.js";
import { n as transform } from "./transform-BzepVlkX.js";
import { z } from "zod";
import crypto from "crypto";

//#region src/providers/sagemaker.ts
/**
* Sleep utility function for implementing delays
* @param ms Milliseconds to sleep
* @returns Promise that resolves after the specified delay
*/
const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
const SUPPORTED_MODEL_TYPES = [
	"openai",
	"llama",
	"huggingface",
	"jumpstart",
	"custom"
];
/**
* Zod schema for validating SageMaker options
*/
const SageMakerConfigSchema = z.strictObject({
	accessKeyId: z.string().optional(),
	profile: z.string().optional(),
	region: z.string().optional(),
	secretAccessKey: z.string().optional(),
	sessionToken: z.string().optional(),
	endpoint: z.string().optional(),
	contentType: z.string().optional(),
	acceptType: z.string().optional(),
	maxTokens: z.number().optional(),
	temperature: z.number().optional(),
	topP: z.number().optional(),
	stopSequences: z.array(z.string()).optional(),
	delay: z.number().optional(),
	transform: z.string().optional(),
	modelType: z.enum(SUPPORTED_MODEL_TYPES).optional(),
	responseFormat: z.strictObject({
		type: z.string().optional(),
		path: z.string().optional()
	}).optional(),
	basePath: z.string().optional()
});
/**
* Base class for SageMaker providers with common functionality
*/
var SageMakerGenericProvider = class {
	env;
	sagemakerRuntime;
	config;
	endpointName;
	delay;
	transform;
	providerId;
	constructor(endpointName, options) {
		const { config, id, env, delay, transform } = options;
		this.env = env;
		this.endpointName = endpointName;
		try {
			SageMakerConfigSchema.parse(config);
		} catch (error) {
			logger_default.warn(`Error validating SageMaker config\nConfig: ${JSON.stringify(config)}\n${error instanceof z.ZodError ? z.prettifyError(error) : error}`);
		}
		this.config = config ?? {};
		this.delay = delay || this.config.delay;
		this.transform = transform || this.config.transform;
		this.providerId = id;
		telemetry_default.record("feature_used", { feature: "sagemaker" });
	}
	id() {
		return this.providerId || `sagemaker:${this.endpointName}`;
	}
	toString() {
		return `[Amazon SageMaker Provider ${this.endpointName}]`;
	}
	/**
	* Get AWS credentials from config or environment
	*/
	async getCredentials() {
		if (this.config.accessKeyId && this.config.secretAccessKey) {
			logger_default.debug("Using explicit credentials from config");
			return {
				accessKeyId: this.config.accessKeyId,
				secretAccessKey: this.config.secretAccessKey,
				sessionToken: this.config.sessionToken
			};
		}
		if (this.config.profile) {
			logger_default.debug(`Using AWS profile: ${this.config.profile}`);
			try {
				const { fromSSO } = await import("@aws-sdk/credential-provider-sso");
				return fromSSO({ profile: this.config.profile });
			} catch {
				throw new Error(`Failed to load AWS SSO profile. Please install @aws-sdk/credential-provider-sso`);
			}
		}
		logger_default.debug("Using default AWS credentials from environment");
	}
	/**
	* Initialize and return the SageMaker runtime client
	*/
	async getSageMakerRuntimeInstance() {
		if (!this.sagemakerRuntime) try {
			const { SageMakerRuntimeClient } = await import("@aws-sdk/client-sagemaker-runtime");
			const credentials = await this.getCredentials();
			this.sagemakerRuntime = new SageMakerRuntimeClient({
				region: this.getRegion(),
				maxAttempts: getEnvInt("AWS_SAGEMAKER_MAX_RETRIES", 3),
				retryMode: "adaptive",
				...credentials ? { credentials } : {}
			});
			logger_default.debug(`SageMaker client initialized for region ${this.getRegion()}`);
		} catch {
			throw new Error("The @aws-sdk/client-sagemaker-runtime package is required. Please install it with: npm install @aws-sdk/client-sagemaker-runtime");
		}
		return this.sagemakerRuntime;
	}
	/**
	* Get AWS region from config or environment
	*/
	getRegion() {
		return this.config?.region || this.env?.AWS_REGION || getEnvString("AWS_REGION") || getEnvString("AWS_DEFAULT_REGION") || "us-east-1";
	}
	/**
	* Get SageMaker endpoint name
	*/
	getEndpointName() {
		return this.config?.endpoint || this.endpointName;
	}
	/**
	* Get content type for request
	*/
	getContentType() {
		return this.config?.contentType || "application/json";
	}
	/**
	* Get accept type for response
	*/
	getAcceptType() {
		return this.config?.acceptType || "application/json";
	}
	/**
	* Apply transformation to a prompt if a transform function is specified
	* @param prompt The original prompt to transform
	* @param context Optional context information for the transformation
	* @returns The transformed prompt, or the original if no transformation is applied
	*/
	async applyTransformation(prompt, context) {
		if (!this.transform) return prompt;
		try {
			const transformContext = {
				vars: context?.vars || {},
				prompt: context?.prompt || { raw: prompt },
				uuid: `sagemaker-${this.endpointName}-${Date.now()}`
			};
			const transformFn = this.transform || context?.originalProvider?.transform;
			if (!transformFn) return prompt;
			logger_default.debug(`Applying transform to prompt for SageMaker endpoint ${this.getEndpointName()}`);
			if (typeof transformFn === "string" && !transformFn.startsWith("file://")) try {
				if (transformFn.includes("=>")) {
					const result = new Function("prompt", "context", `try { return (${transformFn})(prompt, context); } catch(e) { throw new Error("Transform function error: " + e.message); }`)(prompt, transformContext);
					if (result === void 0 || result === null) {
						logger_default.debug("Transform function returned null or undefined, using original prompt");
						return prompt;
					}
					if (typeof result === "string") return result;
					else if (typeof result === "object") return JSON.stringify(result);
					else return String(result);
				} else {
					const result = new Function("prompt", "context", `try { ${transformFn} } catch(e) { throw new Error("Transform function error: " + e.message); }`)(prompt, transformContext);
					if (result === void 0 || result === null) {
						logger_default.debug("Transform function returned null or undefined, using original prompt");
						return prompt;
					}
					if (typeof result === "string") return result;
					else if (typeof result === "object") return JSON.stringify(result);
					else return String(result);
				}
			} catch (transformError) {
				logger_default.error(`Error executing inline transform: ${transformError}`);
			}
			else try {
				const { TransformInputType } = await import("./transform-1g7fEAge.js");
				const transformed = await transform(transformFn, prompt, transformContext, false, TransformInputType.OUTPUT);
				if (transformed === void 0 || transformed === null) {
					logger_default.debug("Transform function returned null or undefined, using original prompt");
					return prompt;
				}
				if (typeof transformed === "string") return transformed;
				else if (typeof transformed === "object") return JSON.stringify(transformed);
				else return String(transformed);
			} catch (transformError) {
				logger_default.error(`Error using transform utility: ${transformError}`);
			}
			logger_default.warn(`Transform did not produce a valid result, using original prompt`);
			return prompt;
		} catch (_) {
			logger_default.error(`Error applying transform to prompt: ${_}`);
			return prompt;
		}
	}
	/**
	* Extracts data from a response using a path expression
	* Supports JavaScript expressions and file-based transforms
	*/
	async extractFromPath(responseJson, pathExpression) {
		if (!pathExpression) return responseJson;
		try {
			if (pathExpression.startsWith("file://")) try {
				const { TransformInputType } = await import("./transform-1g7fEAge.js");
				const transformedResult = await transform(pathExpression, responseJson, { prompt: {} }, false, TransformInputType.OUTPUT);
				return transformedResult !== void 0 && transformedResult !== null ? transformedResult : responseJson;
			} catch (error) {
				logger_default.warn(`Failed to transform response using file: ${error}`);
				return responseJson;
			}
			try {
				const result = new Function("json", `try { return ${pathExpression}; } catch(e) { return undefined; }`)(responseJson);
				if (result === void 0) {
					logger_default.warn(`Path expression "${pathExpression}" did not match any data in the response`);
					logger_default.debug(`Response JSON structure: ${JSON.stringify(responseJson).substring(0, 200)}...`);
					return responseJson;
				}
				return result;
			} catch (error) {
				logger_default.warn(`Failed to evaluate expression "${pathExpression}": ${error}`);
				return responseJson;
			}
		} catch (error) {
			logger_default.warn(`Failed to extract data using path expression "${pathExpression}": ${error}`);
			logger_default.debug(`Response JSON structure: ${JSON.stringify(responseJson).substring(0, 200)}...`);
			return responseJson;
		}
	}
};
/**
* Provider for text generation with SageMaker endpoints
*/
var SageMakerCompletionProvider = class extends SageMakerGenericProvider {
	modelType;
	constructor(endpointName, options) {
		super(endpointName, options);
		this.modelType = this.parseModelType(options.config?.modelType);
	}
	/**
	* Model type must be specified within the id or the `config.modelType` field.
	*/
	parseModelType(modelType) {
		const match = this.id().match(/^sagemaker:(?<modelType>.+):.+$/);
		if (match) {
			const modelTypeFromId = match.groups.modelType;
			if (SUPPORTED_MODEL_TYPES.includes(modelTypeFromId)) return modelTypeFromId;
			else throw new Error(`Invalid model type "${modelTypeFromId}" in provider ID. Valid types are: ${SUPPORTED_MODEL_TYPES.join(", ")}`);
		}
		if (modelType) if (SUPPORTED_MODEL_TYPES.includes(modelType)) return modelType;
		else throw new Error(`Invalid model type "${modelType}" in \`config.modelType\`. Valid types are: ${SUPPORTED_MODEL_TYPES.join(", ")}`);
		throw new Error("Model type must be set either in `config.modelType` or as part of the Provider ID, for example: \"sagemaker:<model_type>:<endpoint>\"");
	}
	/**
	* Format the request payload based on model type
	*/
	formatPayload(prompt) {
		const maxTokens = this.config.maxTokens || getEnvInt("AWS_SAGEMAKER_MAX_TOKENS") || 1024;
		const temperature = typeof this.config.temperature === "number" ? this.config.temperature : getEnvFloat("AWS_SAGEMAKER_TEMPERATURE") ?? .7;
		const topP = typeof this.config.topP === "number" ? this.config.topP : getEnvFloat("AWS_SAGEMAKER_TOP_P") ?? 1;
		const stopSequences = this.config.stopSequences || [];
		let payload;
		logger_default.debug(`Formatting payload for model type: ${this.modelType}`);
		switch (this.modelType) {
			case "openai":
				try {
					const messages = JSON.parse(prompt);
					if (Array.isArray(messages)) payload = {
						messages,
						max_tokens: maxTokens,
						temperature,
						top_p: topP,
						stop: stopSequences.length > 0 ? stopSequences : void 0
					};
					else throw new Error("Not valid messages format");
				} catch {
					payload = {
						prompt,
						max_tokens: maxTokens,
						temperature,
						top_p: topP,
						stop: stopSequences.length > 0 ? stopSequences : void 0
					};
				}
				break;
			case "llama":
				try {
					const messages = JSON.parse(prompt);
					if (Array.isArray(messages)) payload = {
						inputs: messages,
						parameters: {
							max_new_tokens: maxTokens,
							temperature,
							top_p: topP,
							stop: stopSequences.length > 0 ? stopSequences : void 0
						}
					};
					else throw new Error("Not valid messages format");
				} catch {
					payload = {
						inputs: prompt,
						parameters: {
							max_new_tokens: maxTokens,
							temperature,
							top_p: topP,
							stop: stopSequences.length > 0 ? stopSequences : void 0
						}
					};
				}
				break;
			case "jumpstart":
				payload = {
					inputs: prompt,
					parameters: {
						max_new_tokens: maxTokens,
						temperature,
						top_p: topP,
						do_sample: temperature > 0
					}
				};
				break;
			case "huggingface":
				payload = {
					inputs: prompt,
					parameters: {
						max_new_tokens: maxTokens,
						temperature,
						top_p: topP,
						do_sample: temperature > 0,
						return_full_text: false
					}
				};
				break;
			default:
				try {
					payload = JSON.parse(prompt);
				} catch {
					payload = { prompt };
				}
				break;
		}
		return JSON.stringify(payload);
	}
	/**
	* Parse the response from SageMaker endpoint
	*/
	async parseResponse(responseBody) {
		let responseJson;
		logger_default.debug(`Parsing response for model type: ${this.modelType}`);
		try {
			responseJson = JSON.parse(responseBody);
		} catch {
			logger_default.debug("Response is not JSON, returning as-is");
			return responseBody;
		}
		if (this.config.responseFormat?.path) try {
			const pathExpression = this.config.responseFormat.path;
			return await this.extractFromPath(responseJson, pathExpression);
		} catch (error) {
			logger_default.warn(`Failed to extract from path: ${this.config.responseFormat.path}, Error: ${error}`);
			logger_default.debug(`Response JSON structure: ${JSON.stringify(responseJson).substring(0, 200)}...`);
			return responseJson;
		}
		if (responseJson.generated_text) {
			logger_default.debug("Detected JumpStart model response format with generated_text field");
			return responseJson.generated_text;
		}
		switch (this.modelType) {
			case "openai": return responseJson.choices?.[0]?.message?.content || responseJson.choices?.[0]?.text || responseJson.generation || responseJson;
			case "llama": return responseJson.generation || responseJson.choices?.[0]?.message?.content || responseJson.choices?.[0]?.text || responseJson;
			case "huggingface": return Array.isArray(responseJson) ? responseJson[0]?.generated_text || responseJson[0] : responseJson.generated_text || responseJson;
			case "jumpstart": return responseJson.generated_text || responseJson;
			default: return responseJson.output || responseJson.generation || responseJson.response || responseJson.text || responseJson.generated_text || responseJson.choices?.[0]?.message?.content || responseJson.choices?.[0]?.text || responseJson;
		}
	}
	/**
	* Generate a consistent cache key for SageMaker requests
	* Uses crypto.createHash to generate a shorter, more efficient key
	*/
	getCacheKey(prompt) {
		const configForKey = {
			endpoint: this.getEndpointName(),
			modelType: this.config.modelType,
			contentType: this.getContentType(),
			acceptType: this.getAcceptType(),
			maxTokens: this.config.maxTokens,
			temperature: this.config.temperature,
			topP: this.config.topP,
			region: this.getRegion()
		};
		const configStr = JSON.stringify(configForKey);
		const promptHash = crypto.createHash("sha256").update(prompt).digest("hex").substring(0, 16);
		const configHash = crypto.createHash("sha256").update(configStr).digest("hex").substring(0, 8);
		return `sagemaker:v1:${this.getEndpointName()}:${promptHash}:${configHash}`;
	}
	/**
	* Invoke SageMaker endpoint for text generation with caching, delay support, and transformations
	*/
	async callApi(prompt, context, _options) {
		const { isCacheEnabled, getCache } = await import("./cache-scuP1IRq.js");
		const delayMs = context?.originalProvider?.delay || this.delay;
		const transformedPrompt = await this.applyTransformation(prompt, context);
		const isTransformed = transformedPrompt !== prompt;
		if (isTransformed) {
			logger_default.debug(`Prompt transformed for SageMaker endpoint ${this.getEndpointName()}`);
			logger_default.debug(`Original: ${prompt.substring(0, 100)}${prompt.length > 100 ? "..." : ""}`);
			logger_default.debug(`Transformed: ${transformedPrompt.substring(0, 100)}${transformedPrompt.length > 100 ? "..." : ""}`);
		}
		const bustCache = context?.bustCache ?? context?.debug === true;
		if (isCacheEnabled() && !bustCache) {
			const cacheKey = this.getCacheKey(transformedPrompt);
			const cachedResult = await (getCache ? getCache() : await import("./cache-scuP1IRq.js").then((m) => m.getCache())).get(cacheKey);
			if (cachedResult) {
				logger_default.debug(`Using cached SageMaker response for ${this.getEndpointName()}`);
				try {
					const parsedResult = JSON.parse(cachedResult);
					if (parsedResult.tokenUsage) parsedResult.tokenUsage.cached = parsedResult.tokenUsage.total || 0;
					if (isTransformed && parsedResult.metadata) {
						parsedResult.metadata.transformed = true;
						parsedResult.metadata.originalPrompt = prompt;
					}
					return {
						...parsedResult,
						cached: true
					};
				} catch (_) {
					logger_default.warn(`Failed to parse cached SageMaker response: ${_}`);
				}
			}
		}
		if (delayMs && delayMs > 0) {
			logger_default.debug(`Applying delay of ${delayMs}ms before calling SageMaker endpoint ${this.getEndpointName()}`);
			await sleep(delayMs);
		}
		const runtime = await this.getSageMakerRuntimeInstance();
		const payload = this.formatPayload(transformedPrompt);
		logger_default.debug(`Calling SageMaker endpoint ${this.getEndpointName()}`);
		logger_default.debug(`With payload: ${payload.length > 1e3 ? payload.substring(0, 1e3) + "..." : payload}`);
		try {
			const { InvokeEndpointCommand } = await import("@aws-sdk/client-sagemaker-runtime");
			const command = new InvokeEndpointCommand({
				EndpointName: this.getEndpointName(),
				ContentType: this.getContentType(),
				Accept: this.getAcceptType(),
				Body: payload
			});
			const startTime = Date.now();
			const response = await runtime.send(command);
			const _latency = Date.now() - startTime;
			if (!response.Body) {
				logger_default.error("No response body returned from SageMaker endpoint");
				return { error: "No response body returned from SageMaker endpoint" };
			}
			const responseBody = new TextDecoder().decode(response.Body);
			logger_default.debug(`SageMaker response (truncated): ${responseBody.length > 1e3 ? responseBody.substring(0, 1e3) + "..." : responseBody}`);
			const output = await this.parseResponse(responseBody);
			if (typeof output === "object" && output !== null && "code" in output) {
				const code = output.code;
				if (Number.isInteger(code) && code === 424) {
					const errorMessage = `API Error: 424${output?.message ? ` ${output.message}` : ""}\n${JSON.stringify(output)}`;
					logger_default.error(errorMessage);
					return { error: errorMessage };
				}
			}
			const promptTokens = Math.ceil(payload.length / 4);
			const completionTokens = Math.ceil((typeof output === "string" ? output.length : 0) / 4);
			const result = {
				output,
				raw: responseBody,
				tokenUsage: {
					prompt: promptTokens,
					completion: completionTokens,
					total: promptTokens + completionTokens,
					cached: 0,
					numRequests: 1
				},
				metadata: {
					latencyMs: _latency,
					modelType: this.config.modelType || "custom",
					transformed: isTransformed,
					originalPrompt: isTransformed ? prompt : void 0
				}
			};
			if (isCacheEnabled() && !bustCache && result.output && !result.error) {
				const cacheKey = this.getCacheKey(transformedPrompt);
				const cache = getCache ? getCache() : await import("./cache-scuP1IRq.js").then((m) => m.getCache());
				const resultToCache = JSON.stringify(result);
				try {
					await cache.set(cacheKey, resultToCache);
					logger_default.debug(`Stored SageMaker response in cache with key: ${cacheKey.substring(0, 100)}...`);
				} catch (_) {
					logger_default.warn(`Failed to store SageMaker response in cache: ${_}`);
				}
			}
			return result;
		} catch (error) {
			logger_default.error(`SageMaker API error: ${error}`);
			return { error: `SageMaker API error: ${error.message || String(error)}` };
		}
	}
};
/**
* Provider for embeddings with SageMaker endpoints
*/
var SageMakerEmbeddingProvider = class extends SageMakerGenericProvider {
	async callApi() {
		throw new Error("callApi is not implemented for embedding provider. Use callEmbeddingApi instead.");
	}
	/**
	* Generate a consistent cache key for SageMaker embedding requests
	* Uses crypto.createHash to generate a shorter, more efficient key
	*/
	getCacheKey(text) {
		const configForKey = {
			endpoint: this.getEndpointName(),
			modelType: this.config.modelType,
			contentType: this.getContentType(),
			acceptType: this.getAcceptType(),
			region: this.getRegion(),
			responseFormat: this.config.responseFormat
		};
		const configStr = JSON.stringify(configForKey);
		const textHash = crypto.createHash("sha256").update(text).digest("hex").substring(0, 16);
		const configHash = crypto.createHash("sha256").update(configStr).digest("hex").substring(0, 8);
		return `sagemaker:embedding:v1:${this.getEndpointName()}:${textHash}:${configHash}`;
	}
	/**
	* Invoke SageMaker endpoint for embeddings with caching, delay support, and transformations
	*/
	async callEmbeddingApi(text, context) {
		const { isCacheEnabled, getCache } = await import("./cache-scuP1IRq.js");
		const delayMs = context?.originalProvider?.delay || this.delay;
		const transformedText = await this.applyTransformation(text, context);
		const isTransformed = transformedText !== text;
		if (isTransformed) {
			logger_default.debug(`Text transformed for SageMaker embedding endpoint ${this.getEndpointName()}`);
			logger_default.debug(`Original: ${text.substring(0, 100)}${text.length > 100 ? "..." : ""}`);
			logger_default.debug(`Transformed: ${transformedText.substring(0, 100)}${transformedText.length > 100 ? "..." : ""}`);
		}
		const bustCache = context?.debug === true;
		if (isCacheEnabled() && !bustCache) {
			const cacheKey = this.getCacheKey(transformedText);
			const cachedResult = await (await getCache ? await getCache() : await import("./cache-scuP1IRq.js").then((m) => m.getCache())).get(cacheKey);
			if (cachedResult) {
				logger_default.debug(`Using cached SageMaker embedding response for ${this.getEndpointName()}`);
				try {
					const parsedResult = JSON.parse(cachedResult);
					if (parsedResult.tokenUsage) parsedResult.tokenUsage.cached = parsedResult.tokenUsage.prompt || 0;
					return {
						...parsedResult,
						cached: true
					};
				} catch (_) {
					logger_default.warn(`Failed to parse cached SageMaker embedding response: ${_}`);
				}
			}
		}
		if (delayMs && delayMs > 0) {
			logger_default.debug(`Applying delay of ${delayMs}ms before calling SageMaker embedding endpoint ${this.getEndpointName()}`);
			await sleep(delayMs);
		}
		const runtime = await this.getSageMakerRuntimeInstance();
		let payload;
		const modelType = this.config.modelType || "custom";
		logger_default.debug(`Formatting embedding payload for model type: ${modelType}`);
		switch (modelType) {
			case "openai":
				payload = JSON.stringify({
					input: transformedText,
					model: "embedding"
				});
				break;
			case "huggingface":
				payload = JSON.stringify({ inputs: transformedText });
				break;
			default:
				payload = JSON.stringify({
					input: transformedText,
					text: transformedText,
					inputs: transformedText
				});
				break;
		}
		logger_default.debug(`Calling SageMaker embedding endpoint ${this.getEndpointName()}`);
		logger_default.debug(`With payload: ${payload}`);
		try {
			const { InvokeEndpointCommand } = await import("@aws-sdk/client-sagemaker-runtime");
			const command = new InvokeEndpointCommand({
				EndpointName: this.getEndpointName(),
				ContentType: this.getContentType(),
				Accept: this.getAcceptType(),
				Body: payload
			});
			const startTime = Date.now();
			const response = await runtime.send(command);
			Date.now() - startTime;
			if (!response.Body) {
				logger_default.error("No response body returned from SageMaker embedding endpoint");
				return { error: "No response body returned from SageMaker embedding endpoint" };
			}
			const responseBody = new TextDecoder().decode(response.Body);
			logger_default.debug(`SageMaker embedding response: ${responseBody.substring(0, 200)}...`);
			let responseJson;
			try {
				responseJson = JSON.parse(responseBody);
			} catch (_) {
				return { error: `Failed to parse embedding response as JSON: ${_}` };
			}
			const embedding = responseJson.embedding || responseJson.embeddings || responseJson.data?.[0]?.embedding || (Array.isArray(responseJson) ? responseJson[0] : responseJson);
			if (this.config.responseFormat?.path) try {
				const pathExpression = this.config.responseFormat.path;
				const extracted = await this.extractFromPath(responseJson, pathExpression);
				if (Array.isArray(extracted) && extracted.every((val) => typeof val === "number")) {
					const result = {
						embedding: extracted,
						tokenUsage: {
							prompt: Math.ceil(text.length / 4),
							cached: 0,
							numRequests: 1
						},
						metadata: {
							transformed: isTransformed,
							originalText: isTransformed ? text : void 0
						}
					};
					await this.cacheEmbeddingResult(result, transformedText, context, isTransformed, isTransformed ? text : void 0);
					return result;
				} else logger_default.warn("Extracted data is not a valid embedding array, trying other extraction methods");
			} catch (error) {
				logger_default.warn(`Failed to extract embedding from path expression: ${this.config.responseFormat.path}, Error: ${error}`);
				logger_default.debug(`Response JSON structure: ${JSON.stringify(responseJson).substring(0, 200)}...`);
			}
			if (!embedding || !Array.isArray(embedding)) return { error: `Invalid embedding response format. Could not find embedding array in: ${JSON.stringify(responseJson).substring(0, 100)}...` };
			const result = {
				embedding,
				tokenUsage: {
					prompt: Math.ceil(text.length / 4),
					cached: 0,
					numRequests: 1
				},
				metadata: {
					transformed: isTransformed,
					originalText: isTransformed ? text : void 0
				}
			};
			await this.cacheEmbeddingResult(result, transformedText, context, isTransformed, isTransformed ? text : void 0);
			return result;
		} catch (error) {
			logger_default.error(`SageMaker embedding API error: ${error}`);
			return { error: `SageMaker embedding API error: ${error.message || String(error)}` };
		}
	}
	/**
	* Helper method to cache embedding results
	*/
	async cacheEmbeddingResult(result, text, context, isTransformed = false, originalText) {
		const { isCacheEnabled, getCache } = await import("./cache-scuP1IRq.js");
		const bustCache = context?.debug === true;
		if (isCacheEnabled() && !bustCache && result.embedding && !result.error) {
			const cacheKey = this.getCacheKey(text);
			const cache = await getCache ? await getCache() : await import("./cache-scuP1IRq.js").then((m) => m.getCache());
			if (isTransformed && originalText && !result.metadata) result.metadata = {
				transformed: true,
				originalText
			};
			else if (isTransformed && originalText && result.metadata) {
				result.metadata.transformed = true;
				result.metadata.originalText = originalText;
			}
			const resultToCache = JSON.stringify(result);
			try {
				await cache.set(cacheKey, resultToCache);
				logger_default.debug(`Stored SageMaker embedding response in cache with key: ${cacheKey.substring(0, 100)}...`);
			} catch (_) {
				logger_default.warn(`Failed to store SageMaker embedding response in cache: ${_}`);
			}
		}
	}
};

//#endregion
export { SageMakerCompletionProvider, SageMakerEmbeddingProvider };
//# sourceMappingURL=sagemaker-B4hvJgkV.js.map