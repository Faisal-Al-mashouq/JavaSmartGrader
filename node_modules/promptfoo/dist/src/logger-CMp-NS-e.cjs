//#region rolldown:runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __exportAll = (all, symbols) => {
	let target = {};
	for (var name in all) {
		__defProp(target, name, {
			get: all[name],
			enumerable: true
		});
	}
	if (symbols) {
		__defProp(target, Symbol.toStringTag, { value: "Module" });
	}
	return target;
};
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") {
		for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {
			key = keys[i];
			if (!__hasOwnProp.call(to, key) && key !== except) {
				__defProp(to, key, {
					get: ((k) => from[k]).bind(null, key),
					enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
				});
			}
		}
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));

//#endregion
const require_invariant = require('./invariant-CKcJAQ6M.cjs');
let fs = require("fs");
fs = __toESM(fs);
let path = require("path");
path = __toESM(path);
let js_yaml = require("js-yaml");
js_yaml = __toESM(js_yaml);
let dotenv = require("dotenv");
dotenv = __toESM(dotenv);
let chalk = require("chalk");
chalk = __toESM(chalk);
let winston = require("winston");
winston = __toESM(winston);
let os = require("os");
os = __toESM(os);
let ajv = require("ajv");
ajv = __toESM(ajv);
let ajv_formats = require("ajv-formats");
ajv_formats = __toESM(ajv_formats);
let fast_safe_stringify = require("fast-safe-stringify");
fast_safe_stringify = __toESM(fast_safe_stringify);

//#region src/cliState.ts
const state = {};
var cliState_default = state;

//#endregion
//#region src/envars.ts
dotenv.default.config({ quiet: true });
function getEnvString(key, defaultValue) {
	if (cliState_default.config?.env && typeof cliState_default.config.env === "object") {
		const envValue = cliState_default.config.env[key];
		if (envValue !== void 0) return String(envValue);
	}
	const value = process.env[key];
	if (value === void 0) return defaultValue;
	return value;
}
/**
* Get a boolean environment variable.
* @param key The name of the environment variable.
* @param defaultValue Optional default value if the environment variable is not set.
* @returns The boolean value of the environment variable, or the default value if provided.
*/
function getEnvBool(key, defaultValue) {
	const value = getEnvString(key) || defaultValue;
	if (typeof value === "boolean") return value;
	if (typeof value === "string") return [
		"1",
		"true",
		"yes",
		"yup",
		"yeppers"
	].includes(value.toLowerCase());
	return Boolean(defaultValue);
}
function getEnvInt(key, defaultValue) {
	const value = getEnvString(key) || defaultValue;
	if (typeof value === "number") return Math.floor(value);
	if (typeof value === "string") {
		const parsedValue = Number.parseInt(value, 10);
		if (!Number.isNaN(parsedValue)) return parsedValue;
	}
	return defaultValue;
}
function getEnvFloat(key, defaultValue) {
	const value = getEnvString(key) || defaultValue;
	if (typeof value === "number") return value;
	if (typeof value === "string") {
		const parsedValue = Number.parseFloat(value);
		if (!Number.isNaN(parsedValue)) return parsedValue;
	}
	return defaultValue;
}
/**
* Get the timeout in milliseconds for each individual test case/provider API call.
* When this timeout is reached, that specific test is marked as an error.
* @param defaultValue Optional default value if the environment variable is not set. Defaults to 0 (no timeout).
* @returns The timeout value in milliseconds, or the default value if not set.
*/
function getEvalTimeoutMs(defaultValue = 0) {
	return getEnvInt("PROMPTFOO_EVAL_TIMEOUT_MS", defaultValue);
}
/**
* Get the maximum total runtime in milliseconds for the entire evaluation process.
* When this timeout is reached, all remaining tests are marked as errors and the evaluation ends.
* @param defaultValue Optional default value if the environment variable is not set. Defaults to 0 (no limit).
* @returns The max duration in milliseconds, or the default value if not set.
*/
function getMaxEvalTimeMs(defaultValue = 0) {
	return getEnvInt("PROMPTFOO_MAX_EVAL_TIME_MS", defaultValue);
}
/**
* Check if the application is running in a CI environment.
* @returns True if running in a CI environment, false otherwise.
*/
function isCI() {
	return getEnvBool("CI") || getEnvBool("GITHUB_ACTIONS") || getEnvBool("TRAVIS") || getEnvBool("CIRCLECI") || getEnvBool("JENKINS") || getEnvBool("GITLAB_CI") || getEnvBool("APPVEYOR") || getEnvBool("CODEBUILD_BUILD_ID") || getEnvBool("TF_BUILD") || getEnvBool("BITBUCKET_COMMIT") || getEnvBool("BUDDY") || getEnvBool("BUILDKITE") || getEnvBool("TEAMCITY_VERSION");
}

//#endregion
//#region src/util/config/manage.ts
let configDirectoryPath = getEnvString("PROMPTFOO_CONFIG_DIR");
const isNodeEnvironment = typeof process !== "undefined" && process.versions && process.versions.node;
function getConfigDirectoryPath(createIfNotExists = false) {
	const p = configDirectoryPath || path.join(os.homedir(), ".promptfoo");
	if (createIfNotExists && isNodeEnvironment) try {
		fs.default.mkdirSync(p, { recursive: true });
	} catch {}
	return p;
}

//#endregion
//#region src/util/json.ts
let ajvInstance = null;
function getAjv() {
	if (!ajvInstance) {
		ajvInstance = new ajv.default({ strictSchema: !getEnvBool("PROMPTFOO_DISABLE_AJV_STRICT_MODE") });
		(0, ajv_formats.default)(ajvInstance);
	}
	return ajvInstance;
}
function isValidJson(str) {
	try {
		JSON.parse(str);
		return true;
	} catch {
		return false;
	}
}
/**
* Creates a truncated version of an object for safe JSON stringification.
* Prevents memory issues by limiting string, array, and object sizes.
*
* @param value - The value to truncate and stringify
* @param prettyPrint - Whether to format the JSON with indentation
* @returns A JSON string representation of the truncated value
*/
function safeJsonStringifyTruncated(value, prettyPrint = false) {
	const cache = /* @__PURE__ */ new Set();
	const space = prettyPrint ? 2 : void 0;
	const truncateValue = (val) => {
		if (typeof val === "string") return val.length > 1e3 ? val.substring(0, 1e3) + "...[truncated]" : val;
		if (Array.isArray(val)) {
			const truncated = val.slice(0, 10).map(truncateValue);
			if (val.length > 10) truncated.push(`...[${val.length - 10} more items]`);
			return truncated;
		}
		if (typeof val === "object" && val !== null) {
			if (cache.has(val)) return "[Circular Reference]";
			cache.add(val);
			const truncated = {};
			let count = 0;
			for (const [k, v] of Object.entries(val)) {
				if (count >= 20) {
					truncated["...[truncated]"] = `${Object.keys(val).length - count} more keys`;
					break;
				}
				truncated[k] = truncateValue(v);
				count++;
			}
			return truncated;
		}
		return val;
	};
	try {
		return JSON.stringify(truncateValue(value), null, space) || "{}";
	} catch {
		return `{"error": "Failed to stringify even truncated data", "type": "${typeof value}", "constructor": "${value?.constructor?.name || "unknown"}"}`;
	}
}
/**
* Safely stringify a value to JSON, handling circular references and large objects.
*
* @param value - The value to stringify
* @param prettyPrint - Whether to format the JSON with indentation
* @returns JSON string representation, or undefined if serialization fails
*/
function safeJsonStringify(value, prettyPrint = false) {
	const cache = /* @__PURE__ */ new Set();
	const space = prettyPrint ? 2 : void 0;
	try {
		return JSON.stringify(value, (_key, val) => {
			if (typeof val === "object" && val !== null) {
				if (cache.has(val)) return;
				cache.add(val);
			}
			return val;
		}, space) || void 0;
	} catch (error) {
		if (error instanceof RangeError && error.message.includes("Invalid string length")) return safeJsonStringifyTruncated(value, prettyPrint);
		return;
	}
}
function convertSlashCommentsToHash(str) {
	return str.split("\n").map((line) => {
		let state = "normal";
		let result = "";
		let i = 0;
		while (i < line.length) {
			const char = line[i];
			const nextChar = line[i + 1];
			const prevChar = i > 0 ? line[i - 1] : "";
			switch (state) {
				case "normal":
					if (char === "'" && !/[a-zA-Z]/.test(prevChar)) {
						state = "singleQuote";
						result += char;
					} else if (char === "\"") {
						state = "doubleQuote";
						result += char;
					} else if (char === "/" && nextChar === "/") {
						let tokenStart = 0;
						for (let j = i - 1; j >= 0; j--) if (/\s/.test(line[j])) {
							tokenStart = j + 1;
							break;
						}
						if (line.slice(tokenStart, i + 2).includes("://")) {
							result += char;
							break;
						}
						let slashCount = 2;
						while (i + slashCount < line.length && line[i + slashCount] === "/") slashCount++;
						const hashes = "#".repeat(Math.floor(slashCount / 2));
						return result + hashes + line.slice(i + slashCount);
					} else result += char;
					break;
				case "singleQuote":
					result += char;
					if (char === "'" && prevChar !== "\\" && !/[a-zA-Z]/.test(nextChar)) state = "normal";
					break;
				case "doubleQuote":
					result += char;
					if (char === "\"" && prevChar !== "\\") state = "normal";
					break;
			}
			i++;
		}
		return result;
	}).join("\n");
}
function extractJsonObjects(str) {
	const jsonObjects = [];
	const maxJsonLength = 1e5;
	for (let i = 0; i < str.length; i++) if (str[i] === "{") {
		let openBraces = 1;
		let closeBraces = 0;
		let j = i + 1;
		while (j < Math.min(i + maxJsonLength, str.length) && openBraces > closeBraces) {
			if (str[j] === "{") openBraces++;
			if (str[j] === "}") closeBraces++;
			j++;
			if (openBraces === closeBraces || j === str.length || j === i + maxJsonLength) try {
				let potentialJson = str.slice(i, j);
				if (openBraces > closeBraces) potentialJson += "}".repeat(openBraces - closeBraces);
				const processedJson = convertSlashCommentsToHash(potentialJson);
				const parsedObj = js_yaml.default.load(processedJson, { json: true });
				if (typeof parsedObj === "object" && parsedObj !== null) {
					jsonObjects.push(parsedObj);
					i = j - 1;
					break;
				}
			} catch {
				if (openBraces === closeBraces) break;
			}
		}
	}
	return jsonObjects;
}
function extractFirstJsonObject(str) {
	const jsonObjects = extractJsonObjects(str);
	require_invariant.invariant(jsonObjects.length >= 1, `Expected a JSON object, but got ${JSON.stringify(str)}`);
	return jsonObjects[0];
}
/**
* Reorders the keys of an object based on a specified order, preserving any unspecified keys.
* Symbol keys are preserved and added at the end.
*
* @param obj - The object whose keys need to be reordered.
* @param order - An array specifying the desired order of keys.
* @returns A new object with keys reordered according to the specified order.
*
* @example
* const obj = { c: 3, a: 1, b: 2 };
* const orderedObj = orderKeys(obj, ['a', 'b']);
* // Result: { a: 1, b: 2, c: 3 }
*/
function orderKeys(obj, order) {
	const result = {};
	for (const key of order) if (key in obj && obj[key] !== void 0) result[key] = obj[key];
	for (const key in obj) if (!(key in result) && obj[key] !== void 0) result[key] = obj[key];
	const symbolKeys = Object.getOwnPropertySymbols(obj);
	for (const sym of symbolKeys) if (obj[sym] !== void 0) result[sym] = obj[sym];
	return result;
}
/**
* Creates a summary of an EvaluateResult for logging purposes, avoiding RangeError
* when stringifying large evaluation results.
*
* Extracts key information while truncating potentially large fields like response
* outputs and metadata values.
*
* @param result - The evaluation result to summarize
* @param maxOutputLength - Maximum length for response output before truncation. Default: 500
* @param includeMetadataKeys - Whether to include metadata keys in the summary. Default: true
* @returns A summarized version safe for JSON stringification
* @throws {TypeError} If result is null or undefined
*/
function summarizeEvaluateResultForLogging(result, maxOutputLength = 500, includeMetadataKeys = true) {
	if (!result) throw new TypeError("EvaluateResult cannot be null or undefined");
	const summary = {
		id: result.id,
		testIdx: result.testIdx,
		promptIdx: result.promptIdx,
		success: result.success,
		score: result.score,
		error: result.error,
		failureReason: result.failureReason
	};
	if (result.provider) summary.provider = {
		id: result.provider.id || "",
		label: result.provider.label
	};
	if (result.response) {
		summary.response = {
			error: result.response.error,
			cached: result.response.cached,
			cost: result.response.cost,
			tokenUsage: result.response.tokenUsage
		};
		if (result.response.output != null) {
			const output = String(result.response.output);
			summary.response.output = output.length > maxOutputLength ? output.substring(0, maxOutputLength) + "...[truncated]" : output;
		}
		if (result.response.metadata && includeMetadataKeys) summary.response.metadata = {
			keys: Object.keys(result.response.metadata),
			keyCount: Object.keys(result.response.metadata).length
		};
	}
	if (result.testCase) summary.testCase = {
		description: result.testCase.description,
		vars: result.testCase.vars ? Object.keys(result.testCase.vars) : void 0
	};
	return summary;
}

//#endregion
//#region src/util/sanitizer.ts
/**
* Generic utility functions for sanitizing objects to prevent logging of secrets and credentials
* Uses a custom recursive approach for reliable deep object sanitization.
*/
const MAX_DEPTH = 4;
const REDACTED = "[REDACTED]";
/**
* Set of field names that should be redacted (case-insensitive, with hyphens/underscores normalized)
* Note: Keys are stored in their normalized form (lowercase, no hyphens/underscores)
*/
const SECRET_FIELD_NAMES = new Set([
	"password",
	"passwd",
	"pwd",
	"secret",
	"secrets",
	"secretkey",
	"credentials",
	"apikey",
	"apisecret",
	"token",
	"accesstoken",
	"refreshtoken",
	"idtoken",
	"bearertoken",
	"authtoken",
	"clientsecret",
	"webhooksecret",
	"authorization",
	"auth",
	"bearer",
	"apikeyenvar",
	"xapikey",
	"xauthtoken",
	"xaccesstoken",
	"xauth",
	"xsecret",
	"xcsrftoken",
	"xsessiondata",
	"csrftoken",
	"sessionid",
	"session",
	"cookie",
	"setcookie",
	"certificatepassword",
	"keystorepassword",
	"pfxpassword",
	"privatekey",
	"certkey",
	"encryptionkey",
	"signingkey",
	"signature",
	"sig",
	"passphrase",
	"certificatecontent",
	"keystorecontent",
	"pfx",
	"pfxcontent",
	"keycontent",
	"certcontent"
]);
/**
* Normalize field names for comparison (lowercase, no hyphens/underscores)
*/
function normalizeFieldName(fieldName) {
	return fieldName.toLowerCase().replace(/[-_]/g, "");
}
/**
* Check if a field name should be redacted
*/
function isSecretField(fieldName) {
	return SECRET_FIELD_NAMES.has(normalizeFieldName(fieldName));
}
/**
* Check if a value looks like a secret based on common patterns.
* Detects API keys, tokens, and other credential patterns.
*/
function looksLikeSecret(value) {
	if (typeof value !== "string") return false;
	if (/^sk-[a-zA-Z0-9-_]{20,}/.test(value)) return true;
	if (/^sk-proj-[a-zA-Z0-9-_]{20,}/.test(value)) return true;
	if (/^sk-ant-[a-zA-Z0-9-_]{20,}/.test(value)) return true;
	if (/^key-[a-zA-Z0-9]{20,}/.test(value)) return true;
	if (/^Bearer\s+.{20,}/i.test(value)) return true;
	if (/^Basic\s+.{20,}/i.test(value)) return true;
	if (/^[a-zA-Z0-9+/=_-]{64,}$/.test(value)) return true;
	if (/^AKIA[A-Z0-9]{16}/.test(value)) return true;
	if (/^AIza[a-zA-Z0-9_-]{35}/.test(value)) return true;
	return false;
}
/**
* Detect class instances (objects with custom prototypes and methods)
*/
function isClassInstance(obj) {
	const proto = Object.getPrototypeOf(obj);
	if (!proto || proto === Object.prototype) return false;
	return Object.getOwnPropertyNames(proto).some((prop) => prop !== "constructor" && typeof proto[prop] === "function");
}
/**
* Parse and sanitize JSON strings, also check if the string looks like a secret
*/
function sanitizeJsonString(str, depth) {
	try {
		const parsed = JSON.parse(str);
		if (parsed && typeof parsed === "object") {
			const sanitized = recursiveSanitize(parsed, depth);
			return JSON.stringify(sanitized);
		}
	} catch {
		if (looksLikeSecret(str)) return REDACTED;
	}
	return str;
}
/**
* Sanitize plain object fields
*/
function sanitizePlainObject(obj, depth) {
	const sanitized = {};
	for (const [key, value] of Object.entries(obj)) if (key === "url" && typeof value === "string") sanitized[key] = sanitizeUrl(value);
	else if (isSecretField(key)) sanitized[key] = REDACTED;
	else if (typeof value === "string" && looksLikeSecret(value)) sanitized[key] = REDACTED;
	else sanitized[key] = recursiveSanitize(value, depth + 1);
	return sanitized;
}
/**
* Recursively sanitize an object, redacting secret fields at any depth
*/
function recursiveSanitize(obj, depth = 0) {
	if (typeof obj === "function") return `[Function] ${obj.name}`;
	if (typeof obj === "string") return sanitizeJsonString(obj, depth);
	if (obj === null || obj === void 0 || typeof obj !== "object") return obj;
	if (depth > MAX_DEPTH) return "[...]";
	if (Array.isArray(obj)) return obj.map((item) => recursiveSanitize(item, depth + 1));
	if (isClassInstance(obj)) return `[${obj.constructor?.name || "Object"} Instance]`;
	return sanitizePlainObject(obj, depth);
}
/**
* Generic function to sanitize any object by removing or redacting sensitive information
* @param obj - The object to sanitize
* @param options - Optional configuration
* @returns A sanitized copy of the object with secrets redacted
*/
function sanitizeObject(obj, options = {}) {
	const { context = "object", throwOnError = false } = options;
	try {
		if (obj === null || obj === void 0) return obj;
		if (typeof obj === "string") return sanitizeJsonString(obj, 0);
		if (typeof obj !== "object") return obj;
		return recursiveSanitize(JSON.parse((0, fast_safe_stringify.default)(obj, (_key, val) => {
			if (val instanceof Error) return {
				name: val.name,
				message: val.message
			};
			return val;
		}, void 0, {
			depthLimit: Number.MAX_SAFE_INTEGER,
			edgesLimit: Number.MAX_SAFE_INTEGER
		})));
	} catch (error) {
		if (throwOnError) throw error;
		console.error(`Error sanitizing ${context}:`, error);
		return obj;
	}
}
function sanitizeUrl(url) {
	try {
		if (typeof url !== "string" || !url.trim()) return url;
		if (url.includes("{{") && url.includes("}}")) return url;
		const parsedUrl = new URL(url);
		const sanitizedUrl = new URL(parsedUrl.href);
		if (sanitizedUrl.username || sanitizedUrl.password) {
			sanitizedUrl.username = "***";
			sanitizedUrl.password = "***";
		}
		const sensitiveParams = /(api[_-]?key|token|password|secret|signature|sig|access[_-]?token|refresh[_-]?token|id[_-]?token|client[_-]?secret|authorization)/i;
		try {
			for (const key of Array.from(sanitizedUrl.searchParams.keys())) if (sensitiveParams.test(key)) sanitizedUrl.searchParams.set(key, "[REDACTED]");
		} catch (paramError) {
			console.warn(`Failed to sanitize URL parameters ${url}: ${paramError}`);
		}
		return sanitizedUrl.toString();
	} catch (error) {
		console.warn(`Failed to sanitize URL ${url}: ${error}`);
		return url;
	}
}

//#endregion
//#region src/logger.ts
let globalLogCallback = null;
function setLogCallback(callback) {
	globalLogCallback = callback;
}
let useStructuredLogging = false;
const LOG_LEVELS = {
	error: 0,
	warn: 1,
	info: 2,
	debug: 3
};
let sourceMapSupportInitialized = false;
let isLoggerShuttingDown = false;
async function initializeSourceMapSupport() {
	if (!sourceMapSupportInitialized) try {
		(await import("source-map-support")).install();
		sourceMapSupportInitialized = true;
	} catch {}
}
/**
* Gets the caller location (filename and line number)
* @returns String with file location information
*/
function getCallerLocation() {
	try {
		const callerLine = ((/* @__PURE__ */ new Error("stack trace capture")).stack?.split("\n") || [])[3];
		if (callerLine) {
			const matchParens = callerLine.match(/at (?:.*) \((.+):(\d+):(\d+)\)/);
			const matchNormal = callerLine.match(/at (.+):(\d+):(\d+)/);
			const match = matchParens || matchNormal;
			if (match) {
				const filePath = match[1];
				const line = match[2];
				return `[${path.default.basename(filePath)}:${line}]`;
			}
		}
	} catch {}
	return "";
}
/**
* Extracts the actual message string from potentially nested info objects
*/
function extractMessage(info) {
	if (typeof info.message === "object" && info.message !== null && "message" in info.message) return typeof info.message.message === "string" ? info.message.message : String(info.message.message);
	return typeof info.message === "string" ? info.message : JSON.stringify(info.message);
}
const consoleFormatter = winston.default.format.printf((info) => {
	const message = extractMessage(info);
	if (globalLogCallback) globalLogCallback(message);
	const location = info.location ? `${info.location} ` : "";
	if (info.level === "error") return chalk.default.red(`${location}${message}`);
	else if (info.level === "warn") return chalk.default.yellow(`${location}${message}`);
	else if (info.level === "info") return `${location}${message}`;
	else if (info.level === "debug") return `${chalk.default.cyan(location)}${message}`;
	throw new Error(`Invalid log level: ${info.level}`);
});
const fileFormatter = winston.default.format.printf((info) => {
	const timestamp = (/* @__PURE__ */ new Date()).toISOString();
	const location = info.location ? ` ${info.location}` : "";
	const message = extractMessage(info);
	return `${timestamp} [${info.level.toUpperCase()}]${location}: ${message}`;
});
const winstonLogger = winston.default.createLogger({
	levels: LOG_LEVELS,
	transports: [new winston.default.transports.Console({
		level: getEnvString("LOG_LEVEL", "info"),
		format: winston.default.format.combine(winston.default.format.simple(), consoleFormatter)
	})]
});
function getLogLevel() {
	return winstonLogger.transports[0].level;
}
function setLogLevel(level) {
	if (level in LOG_LEVELS) {
		winstonLogger.transports[0].level = level;
		if (level === "debug") initializeSourceMapSupport();
	} else throw new Error(`Invalid log level: ${level}`);
}
function isDebugEnabled() {
	return getLogLevel() === "debug";
}
/**
* Creates a logger method for the specified log level.
* Accepts either a string message or a structured object with a message field.
*/
function createLogMethod(level) {
	return (input) => {
		const location = level === "debug" ? getCallerLocation() : isDebugEnabled() ? getCallerLocation() : "";
		if (level === "debug") initializeSourceMapSupport();
		const message = typeof input === "string" ? input : input.message;
		return winstonLogger[level]({
			message,
			location
		});
	};
}
let internalLogger = Object.assign({}, winstonLogger, {
	error: createLogMethod("error"),
	warn: createLogMethod("warn"),
	info: createLogMethod("info"),
	debug: createLogMethod("debug"),
	add: winstonLogger.add.bind(winstonLogger),
	remove: winstonLogger.remove.bind(winstonLogger),
	transports: winstonLogger.transports
});
/**
* Sanitizes context object for logging using generic sanitization
*/
function sanitizeContext(context) {
	const contextWithSanitizedUrls = {};
	for (const [key, value] of Object.entries(context)) if (key === "url" && typeof value === "string") contextWithSanitizedUrls[key] = sanitizeUrl(value);
	else contextWithSanitizedUrls[key] = value;
	return sanitizeObject(contextWithSanitizedUrls, { context: "log context" });
}
/**
* Creates a log method that accepts an optional context parameter.
* If context is provided, it will be sanitized and formatted.
*
* When structured logging is enabled (via setStructuredLogging(true)):
* - Passes { message, ...context } object to the logger
* - Ideal for cloud logging integrations that expect structured data
*
* When structured logging is disabled (default):
* - Formats context as JSON string appended to message
* - Suitable for CLI/console output
*/
function createLogMethodWithContext(level) {
	return (message, context) => {
		if (isLoggerShuttingDown) return;
		if (!context) {
			internalLogger[level](message);
			return;
		}
		const sanitized = sanitizeContext(context);
		if (useStructuredLogging) internalLogger[level]({
			message,
			...sanitized
		});
		else {
			const contextStr = safeJsonStringify(sanitized, true);
			internalLogger[level](`${message}\n${contextStr}`);
		}
	};
}
const logger = {
	error: createLogMethodWithContext("error"),
	warn: createLogMethodWithContext("warn"),
	info: createLogMethodWithContext("info"),
	debug: createLogMethodWithContext("debug"),
	add: (transport) => internalLogger.add ? internalLogger.add(transport) : void 0,
	remove: (transport) => internalLogger.remove ? internalLogger.remove(transport) : void 0,
	get transports() {
		return internalLogger.transports || [];
	},
	get level() {
		return internalLogger.transports?.[0]?.level || "info";
	},
	set level(newLevel) {
		if (internalLogger.transports?.[0]) internalLogger.transports[0].level = newLevel;
	}
};
/**
* Logs request/response details in a formatted way
* @param url - Request URL
* @param requestBody - Request body object
* @param response - Response object (optional)
* @param error - Whether to log as error (true) or debug (false)
*/
async function logRequestResponse(options) {
	const { url, requestBody, requestMethod, response, error } = options;
	const logMethod = error ? logger.error : logger.debug;
	let responseText = "";
	if (response) try {
		responseText = await response.clone().text();
	} catch {
		responseText = "Unable to read response";
	}
	const logObject = {
		message: "API request",
		url: sanitizeUrl(url),
		method: requestMethod,
		requestBody: sanitizeObject(requestBody, { context: "request body" }),
		...response && {
			status: response.status,
			statusText: response.statusText
		},
		...responseText && { response: responseText }
	};
	if (useStructuredLogging) {
		const { message, ...context } = logObject;
		logMethod(message, context);
	} else logMethod("Api Request", logObject);
}
if (getEnvString("LOG_LEVEL", "info") === "debug") initializeSourceMapSupport();
var logger_default = logger;

//#endregion
Object.defineProperty(exports, '__exportAll', {
  enumerable: true,
  get: function () {
    return __exportAll;
  }
});
Object.defineProperty(exports, '__toESM', {
  enumerable: true,
  get: function () {
    return __toESM;
  }
});
Object.defineProperty(exports, 'cliState_default', {
  enumerable: true,
  get: function () {
    return cliState_default;
  }
});
Object.defineProperty(exports, 'extractFirstJsonObject', {
  enumerable: true,
  get: function () {
    return extractFirstJsonObject;
  }
});
Object.defineProperty(exports, 'extractJsonObjects', {
  enumerable: true,
  get: function () {
    return extractJsonObjects;
  }
});
Object.defineProperty(exports, 'getAjv', {
  enumerable: true,
  get: function () {
    return getAjv;
  }
});
Object.defineProperty(exports, 'getConfigDirectoryPath', {
  enumerable: true,
  get: function () {
    return getConfigDirectoryPath;
  }
});
Object.defineProperty(exports, 'getEnvBool', {
  enumerable: true,
  get: function () {
    return getEnvBool;
  }
});
Object.defineProperty(exports, 'getEnvFloat', {
  enumerable: true,
  get: function () {
    return getEnvFloat;
  }
});
Object.defineProperty(exports, 'getEnvInt', {
  enumerable: true,
  get: function () {
    return getEnvInt;
  }
});
Object.defineProperty(exports, 'getEnvString', {
  enumerable: true,
  get: function () {
    return getEnvString;
  }
});
Object.defineProperty(exports, 'getEvalTimeoutMs', {
  enumerable: true,
  get: function () {
    return getEvalTimeoutMs;
  }
});
Object.defineProperty(exports, 'getLogLevel', {
  enumerable: true,
  get: function () {
    return getLogLevel;
  }
});
Object.defineProperty(exports, 'getMaxEvalTimeMs', {
  enumerable: true,
  get: function () {
    return getMaxEvalTimeMs;
  }
});
Object.defineProperty(exports, 'isCI', {
  enumerable: true,
  get: function () {
    return isCI;
  }
});
Object.defineProperty(exports, 'isDebugEnabled', {
  enumerable: true,
  get: function () {
    return isDebugEnabled;
  }
});
Object.defineProperty(exports, 'isValidJson', {
  enumerable: true,
  get: function () {
    return isValidJson;
  }
});
Object.defineProperty(exports, 'logRequestResponse', {
  enumerable: true,
  get: function () {
    return logRequestResponse;
  }
});
Object.defineProperty(exports, 'logger_default', {
  enumerable: true,
  get: function () {
    return logger_default;
  }
});
Object.defineProperty(exports, 'orderKeys', {
  enumerable: true,
  get: function () {
    return orderKeys;
  }
});
Object.defineProperty(exports, 'safeJsonStringify', {
  enumerable: true,
  get: function () {
    return safeJsonStringify;
  }
});
Object.defineProperty(exports, 'sanitizeObject', {
  enumerable: true,
  get: function () {
    return sanitizeObject;
  }
});
Object.defineProperty(exports, 'sanitizeUrl', {
  enumerable: true,
  get: function () {
    return sanitizeUrl;
  }
});
Object.defineProperty(exports, 'setLogCallback', {
  enumerable: true,
  get: function () {
    return setLogCallback;
  }
});
Object.defineProperty(exports, 'setLogLevel', {
  enumerable: true,
  get: function () {
    return setLogLevel;
  }
});
Object.defineProperty(exports, 'summarizeEvaluateResultForLogging', {
  enumerable: true,
  get: function () {
    return summarizeEvaluateResultForLogging;
  }
});
//# sourceMappingURL=logger-CMp-NS-e.cjs.map