import { A as logger_default, P as getEnvString, _ as getCache, c as OpenAiChatCompletionProvider, d as AnthropicMessagesProvider, j as invariant, v as isCacheEnabled } from "./server/index.js";
import fs from "fs";
import path from "path";
import dedent from "dedent";
import crypto from "crypto";

//#region src/providers/agentic-utils.ts
/**
* Shared utilities for agentic providers (Claude Agent SDK, OpenCode SDK, etc.)
*
* These utilities handle common functionality needed by coding agent providers:
* - Working directory fingerprinting for cache key generation
* - Response caching with fingerprint support
*/
/**
* Timeout for working directory fingerprint generation (ms)
* Prevents hanging on extremely large directories
*/
const FINGERPRINT_TIMEOUT_MS = 2e3;
/**
* Get a fingerprint for a working directory to use as a cache key.
* Checks directory mtime and descendant file mtimes recursively.
*
* This allows for caching prompts that use the same working directory
* when the files haven't changed.
*
* @param workingDir - Absolute path to the working directory
* @returns SHA-256 hash fingerprint of the directory state
* @throws Error if fingerprinting times out or directory is inaccessible
*/
async function getWorkingDirFingerprint(workingDir) {
	const dirMtime = fs.statSync(workingDir).mtimeMs;
	const startTime = Date.now();
	const getAllFiles = (dir, files = []) => {
		if (Date.now() - startTime > FINGERPRINT_TIMEOUT_MS) throw new Error("Working directory fingerprint timed out");
		const entries = fs.readdirSync(dir, { withFileTypes: true });
		for (const entry of entries) {
			const fullPath = path.join(dir, entry.name);
			if (entry.isDirectory()) getAllFiles(fullPath, files);
			else if (entry.isFile()) files.push(fullPath);
		}
		return files;
	};
	const fingerprintData = `dir:${dirMtime};files:${getAllFiles(workingDir).map((file) => {
		const stat = fs.statSync(file);
		return `${path.relative(workingDir, file)}:${stat.mtimeMs}`;
	}).sort().join(",")}`;
	return crypto.createHash("sha256").update(fingerprintData).digest("hex");
}
/**
* Generate a cache key from arbitrary data using SHA-256 hash
*
* @param prefix - Cache key prefix (provider identifier)
* @param data - Data to hash for the cache key
* @returns Prefixed SHA-256 hash cache key
*/
function generateCacheKey(prefix, data) {
	const stringified = JSON.stringify(data);
	return `${prefix}:${crypto.createHash("sha256").update(stringified).digest("hex")}`;
}
/**
* Initialize cache and check for cached response
*
* This handles the common caching pattern used by agentic providers:
* 1. Check if caching is enabled
* 2. Generate working directory fingerprint if needed
* 3. Generate cache key
* 4. Return cache configuration for use by the provider
*
* @param options - Cache options including prefix and working directory
* @param cacheKeyData - Data to include in the cache key
* @returns Cache configuration and optional cached response
*/
async function initializeAgenticCache(options, cacheKeyData) {
	if (!isCacheEnabled()) return {
		shouldCache: false,
		shouldReadCache: false,
		shouldWriteCache: false
	};
	let workingDirFingerprint = null;
	if (options.workingDir) try {
		workingDirFingerprint = await getWorkingDirFingerprint(options.workingDir);
	} catch (error) {
		logger_default.error(dedent`Error getting working directory fingerprint for cache key - ${options.workingDir}: ${String(error)}

        Caching is disabled.`);
		return {
			shouldCache: false,
			shouldReadCache: false,
			shouldWriteCache: false
		};
	}
	const cache = await getCache();
	const cacheKey = generateCacheKey(options.cacheKeyPrefix, {
		...cacheKeyData,
		workingDirFingerprint
	});
	return {
		shouldCache: true,
		shouldReadCache: !options.bustCache,
		shouldWriteCache: true,
		cache,
		cacheKey,
		workingDirFingerprint
	};
}
/**
* Try to get a cached response
*
* @param cacheResult - Result from initializeAgenticCache
* @param debugContext - Context for debug logging (e.g., prompt preview)
* @returns Cached ProviderResponse if found, undefined otherwise
*/
async function getCachedResponse(cacheResult, debugContext) {
	if (!cacheResult.shouldReadCache || !cacheResult.cache || !cacheResult.cacheKey) return;
	try {
		const cachedResponse = await cacheResult.cache.get(cacheResult.cacheKey);
		if (cachedResponse) {
			logger_default.debug(`Returning cached response${debugContext ? ` for ${debugContext}` : ""} (cache key: ${cacheResult.cacheKey})`);
			return {
				...JSON.parse(cachedResponse),
				cached: true
			};
		}
	} catch (error) {
		logger_default.error(`Error getting cached response: ${String(error)}`);
	}
}
/**
* Cache a provider response
*
* @param cacheResult - Result from initializeAgenticCache
* @param response - The ProviderResponse to cache
* @param debugContext - Context for debug logging
*/
async function cacheResponse(cacheResult, response, debugContext) {
	if (!cacheResult.shouldWriteCache || !cacheResult.cache || !cacheResult.cacheKey) return;
	try {
		await cacheResult.cache.set(cacheResult.cacheKey, JSON.stringify(response));
	} catch (error) {
		logger_default.error(`Error caching response${debugContext ? ` for ${debugContext}` : ""}: ${String(error)}`);
	}
}

//#endregion
//#region src/providers/cloudflare-gateway.ts
/**
* Cloudflare AI Gateway Provider
*
* Routes requests to AI providers (OpenAI, Anthropic, etc.) through Cloudflare AI Gateway.
* Provides caching, rate limiting, analytics, and cost tracking.
*
* Gateway URL format: https://gateway.ai.cloudflare.com/v1/{account_id}/{gateway_id}/{provider}
*
* Usage:
*   cloudflare-gateway:openai:gpt-4o
*   cloudflare-gateway:anthropic:claude-sonnet-4-20250514
*   cloudflare-gateway:groq:llama-3.3-70b-versatile
*
* @see https://developers.cloudflare.com/ai-gateway/
*/
const CLOUDFLARE_GATEWAY_BASE_URL = "https://gateway.ai.cloudflare.com/v1";
/**
* Supported provider configurations for Cloudflare AI Gateway
*
* Note: Some providers have special URL requirements:
* - azure-openai: Requires resourceName and deploymentName in config
* - workers-ai: Model name is appended to URL path
*
* AWS Bedrock is NOT supported because it requires AWS request signing
* which is incompatible with the gateway proxy approach.
*/
const PROVIDER_CONFIGS = {
	openai: { apiKeyEnvar: "OPENAI_API_KEY" },
	anthropic: { apiKeyEnvar: "ANTHROPIC_API_KEY" },
	groq: { apiKeyEnvar: "GROQ_API_KEY" },
	"perplexity-ai": { apiKeyEnvar: "PERPLEXITY_API_KEY" },
	"google-ai-studio": { apiKeyEnvar: "GOOGLE_API_KEY" },
	mistral: { apiKeyEnvar: "MISTRAL_API_KEY" },
	cohere: { apiKeyEnvar: "COHERE_API_KEY" },
	"azure-openai": { apiKeyEnvar: "AZURE_OPENAI_API_KEY" },
	"workers-ai": { apiKeyEnvar: "CLOUDFLARE_API_KEY" },
	huggingface: { apiKeyEnvar: "HUGGINGFACE_API_KEY" },
	replicate: { apiKeyEnvar: "REPLICATE_API_KEY" },
	grok: { apiKeyEnvar: "XAI_API_KEY" }
};
/**
* Get a custom environment variable value safely
* Uses process.env directly for arbitrary env var names to avoid type casting issues
*/
function getCustomEnvValue(envVarName, env) {
	const envOverrideValue = env?.[envVarName];
	if (envOverrideValue) return envOverrideValue;
	return process.env[envVarName];
}
/**
* Get the Cloudflare account ID from config or environment
*/
function getAccountId(config, env) {
	if (config?.accountId) return config.accountId;
	if (config?.accountIdEnvar) {
		const customValue = getCustomEnvValue(config.accountIdEnvar, env);
		if (customValue) return customValue;
		logger_default.warn(`[CloudflareGateway] Custom account ID environment variable '${config.accountIdEnvar}' is not set. Falling back to CLOUDFLARE_ACCOUNT_ID.`);
	}
	const accountIdCandidate = env?.CLOUDFLARE_ACCOUNT_ID || getEnvString("CLOUDFLARE_ACCOUNT_ID");
	invariant(accountIdCandidate, "Cloudflare account ID required. Supply it via config accountId or accountIdEnvar, or the CLOUDFLARE_ACCOUNT_ID environment variable");
	return accountIdCandidate;
}
/**
* Get the Cloudflare AI Gateway ID from config or environment
*/
function getGatewayId(config, env) {
	if (config?.gatewayId) return config.gatewayId;
	if (config?.gatewayIdEnvar) {
		const customValue = getCustomEnvValue(config.gatewayIdEnvar, env);
		if (customValue) return customValue;
		logger_default.warn(`[CloudflareGateway] Custom gateway ID environment variable '${config.gatewayIdEnvar}' is not set. Falling back to CLOUDFLARE_GATEWAY_ID.`);
	}
	const gatewayIdCandidate = env?.CLOUDFLARE_GATEWAY_ID || getEnvString("CLOUDFLARE_GATEWAY_ID");
	invariant(gatewayIdCandidate, "Cloudflare AI Gateway ID required. Supply it via config gatewayId or gatewayIdEnvar, or the CLOUDFLARE_GATEWAY_ID environment variable");
	return gatewayIdCandidate;
}
/**
* Get the optional Cloudflare AI Gateway authentication token
*/
function getCfAigToken(config, env) {
	if (config?.cfAigToken) return config.cfAigToken;
	if (config?.cfAigTokenEnvar) {
		const customValue = getCustomEnvValue(config.cfAigTokenEnvar, env);
		if (customValue) return customValue;
	}
	return env?.CF_AIG_TOKEN || getEnvString("CF_AIG_TOKEN");
}
/**
* Build the Cloudflare AI Gateway URL for a specific provider
*
* Most providers use: https://gateway.ai.cloudflare.com/v1/{account_id}/{gateway_id}/{provider}
* Azure OpenAI uses: https://gateway.ai.cloudflare.com/v1/{account_id}/{gateway_id}/azure-openai/{resource_name}/{deployment_name}
* Workers AI uses: https://gateway.ai.cloudflare.com/v1/{account_id}/{gateway_id}/workers-ai/{model_id}
*/
function buildGatewayUrl(accountId, gatewayId, provider, config, modelName) {
	const baseUrl = `${CLOUDFLARE_GATEWAY_BASE_URL}/${accountId}/${gatewayId}`;
	if (provider === "azure-openai") {
		const resourceName = config?.resourceName;
		const deploymentName = config?.deploymentName;
		invariant(resourceName, "Azure OpenAI requires resourceName in config. Example: cloudflare-gateway:azure-openai:gpt-4 with config.resourceName set");
		invariant(deploymentName, "Azure OpenAI requires deploymentName in config. Example: cloudflare-gateway:azure-openai:gpt-4 with config.deploymentName set");
		return `${baseUrl}/azure-openai/${resourceName}/${deploymentName}`;
	}
	if (provider === "workers-ai") {
		invariant(modelName, "Workers AI requires a model name (e.g., @cf/meta/llama-3.1-8b-instruct)");
		return `${baseUrl}/workers-ai/${modelName}`;
	}
	return `${baseUrl}/${provider}`;
}
/**
* Extract Cloudflare-specific config keys that shouldn't be passed to the underlying provider
*/
function getPassthroughConfig(config) {
	const { accountId: _accountId, accountIdEnvar: _accountIdEnvar, gatewayId: _gatewayId, gatewayIdEnvar: _gatewayIdEnvar, cfAigToken: _cfAigToken, cfAigTokenEnvar: _cfAigTokenEnvar, resourceName: _resourceName, deploymentName: _deploymentName, apiVersion: _apiVersion, ...passthrough } = config || {};
	return passthrough;
}
/**
* Cloudflare AI Gateway provider for OpenAI-compatible APIs
*
* Routes requests to OpenAI, Groq, Perplexity, Mistral, etc. through Cloudflare AI Gateway
*/
var CloudflareGatewayOpenAiProvider = class extends OpenAiChatCompletionProvider {
	underlyingProvider;
	constructor(underlyingProvider, modelName, providerOptions) {
		const gatewayUrl = buildGatewayUrl(getAccountId(providerOptions.config, providerOptions.env), getGatewayId(providerOptions.config, providerOptions.env), underlyingProvider, providerOptions.config, modelName);
		const passthrough = getPassthroughConfig(providerOptions.config);
		const providerConfig = PROVIDER_CONFIGS[underlyingProvider];
		const cfAigToken = getCfAigToken(providerOptions.config, providerOptions.env);
		const headers = { ...providerOptions.config?.headers || {} };
		if (cfAigToken) headers["cf-aig-authorization"] = `Bearer ${cfAigToken}`;
		let finalGatewayUrl = gatewayUrl;
		let apiKeyEnvar;
		if (underlyingProvider === "azure-openai") {
			const azureApiKey = providerOptions.config?.apiKey || getEnvString("AZURE_OPENAI_API_KEY");
			invariant(azureApiKey, "Azure OpenAI API key is required. Set the AZURE_OPENAI_API_KEY environment variable or add apiKey to the provider config.");
			headers["api-key"] = azureApiKey;
			apiKeyEnvar = void 0;
			finalGatewayUrl = `${gatewayUrl}?api-version=${providerOptions.config?.apiVersion || "2024-12-01-preview"}`;
		} else apiKeyEnvar = providerOptions.config?.apiKeyEnvar || providerConfig?.apiKeyEnvar;
		const config = {
			...passthrough,
			apiKeyEnvar,
			apiBaseUrl: finalGatewayUrl,
			headers: Object.keys(headers).length > 0 ? headers : void 0
		};
		super(modelName, {
			...providerOptions,
			config
		});
		this.underlyingProvider = underlyingProvider;
		logger_default.debug(`[CloudflareGateway] Configured ${underlyingProvider}:${modelName}`, {
			gatewayUrl: finalGatewayUrl,
			hasApiKey: !!providerOptions.config?.apiKey,
			hasCfAigToken: !!cfAigToken
		});
	}
	id() {
		return `cloudflare-gateway:${this.underlyingProvider}:${this.modelName}`;
	}
	toString() {
		return `[Cloudflare AI Gateway ${this.underlyingProvider} Provider ${this.modelName}]`;
	}
	toJSON() {
		return {
			provider: "cloudflare-gateway",
			underlyingProvider: this.underlyingProvider,
			model: this.modelName,
			config: {
				...this.config,
				apiKey: void 0
			}
		};
	}
};
/**
* Extract Anthropic-compatible options from the gateway config
*/
function getAnthropicPassthroughConfig(config) {
	if (!config) return {};
	const { apiKey, max_tokens, temperature, top_p, cost } = config;
	const top_k = config.top_k;
	return {
		...apiKey !== void 0 && { apiKey },
		...max_tokens !== void 0 && { max_tokens },
		...temperature !== void 0 && { temperature },
		...top_p !== void 0 && { top_p },
		...top_k !== void 0 && { top_k },
		...cost !== void 0 && { cost }
	};
}
/**
* Cloudflare AI Gateway provider for Anthropic
*
* Routes requests to Anthropic through Cloudflare AI Gateway
*/
var CloudflareGatewayAnthropicProvider = class extends AnthropicMessagesProvider {
	constructor(modelName, providerOptions) {
		const gatewayUrl = buildGatewayUrl(getAccountId(providerOptions.config, providerOptions.env), getGatewayId(providerOptions.config, providerOptions.env), "anthropic");
		const passthrough = getAnthropicPassthroughConfig(providerOptions.config);
		const cfAigToken = getCfAigToken(providerOptions.config, providerOptions.env);
		const headers = { ...providerOptions.config?.headers || {} };
		if (cfAigToken) headers["cf-aig-authorization"] = `Bearer ${cfAigToken}`;
		const config = {
			...passthrough,
			apiBaseUrl: gatewayUrl,
			headers: Object.keys(headers).length > 0 ? headers : void 0
		};
		super(modelName, {
			...providerOptions,
			config
		});
		logger_default.debug(`[CloudflareGateway] Configured anthropic:${modelName}`, {
			gatewayUrl,
			hasApiKey: !!providerOptions.config?.apiKey,
			hasCfAigToken: !!cfAigToken
		});
	}
	id() {
		return `cloudflare-gateway:anthropic:${this.modelName}`;
	}
	toString() {
		return `[Cloudflare AI Gateway Anthropic Provider ${this.modelName}]`;
	}
	toJSON() {
		return {
			provider: "cloudflare-gateway",
			underlyingProvider: "anthropic",
			model: this.modelName,
			config: {
				...this.config,
				apiKey: void 0
			}
		};
	}
};
/**
* Create a Cloudflare AI Gateway provider from a provider path
*
* @param providerPath - Provider path in format cloudflare-gateway:{provider}:{model}
* @param options - Provider options including config and environment
* @returns Configured provider instance
*
* @example
* ```yaml
* providers:
*   - id: cloudflare-gateway:openai:gpt-4o
*     config:
*       accountId: ${CLOUDFLARE_ACCOUNT_ID}
*       gatewayId: ${CLOUDFLARE_GATEWAY_ID}
*       temperature: 0.7
* ```
*/
function createCloudflareGatewayProvider(providerPath, options = {}) {
	const splits = providerPath.split(":");
	if (splits.length < 3) throw new Error(`Invalid cloudflare-gateway provider path: "${providerPath}". Expected format: cloudflare-gateway:{provider}:{model} (e.g., cloudflare-gateway:openai:gpt-4o)`);
	const underlyingProvider = splits[1];
	const modelName = splits.slice(2).join(":");
	invariant(modelName, "Model name is required for cloudflare-gateway provider");
	if (!PROVIDER_CONFIGS[underlyingProvider]) throw new Error(`Unsupported Cloudflare AI Gateway provider: "${underlyingProvider}". Supported providers: ${Object.keys(PROVIDER_CONFIGS).join(", ")}`);
	if (underlyingProvider === "anthropic") return new CloudflareGatewayAnthropicProvider(modelName, options);
	return new CloudflareGatewayOpenAiProvider(underlyingProvider, modelName, options);
}

//#endregion
export { createCloudflareGatewayProvider, getCachedResponse as n, initializeAgenticCache as r, cacheResponse as t };
//# sourceMappingURL=cloudflare-gateway-Bk3YZvTs.js.map