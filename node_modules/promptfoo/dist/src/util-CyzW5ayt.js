#!/usr/bin/env node
import { O as cliState_default, b as getEnvBool, o as logger_default } from "./logger-Bzi5o47S.js";
import { T as TERMINAL_MAX_WIDTH, j as VERSION, t as fetchWithProxy } from "./fetch-TcCC0nEJ.js";
import { t as invariant } from "./invariant-DT20jrBd.js";
import { m as isProviderOptions, o as OutputFileExtension, p as isApiProvider, s as ResultFailureReason } from "./types-n3ttAnOa.js";
import { i as isJavascriptFile, t as JAVASCRIPT_EXTENSIONS } from "./fileExtensions-BpuMmaFL.js";
import { o as safeResolve, r as importModule, t as getDirectory } from "./esm-Bwuh5HXW.js";
import { r as runPython } from "./pythonUtils-mprm8p4h.js";
import dotenv from "dotenv";
import * as fs$2 from "fs";
import * as path$1 from "path";
import path from "path";
import * as os$1 from "os";
import yaml from "js-yaml";
import * as fsPromises from "fs/promises";
import dedent from "dedent";
import deepEqual from "fast-deep-equal";
import { parse as parse$1 } from "csv-parse/sync";
import { globSync, hasMagic } from "glob";
import nunjucks from "nunjucks";
import { XMLBuilder } from "fast-xml-parser";
import { stringify } from "csv-stringify/sync";

//#region src/util/provider.ts
function canonicalizeProviderId(id) {
	if (id.startsWith("file://")) {
		const filePath = id.slice(7);
		return path$1.isAbsolute(filePath) ? id : `file://${path$1.resolve(filePath)}`;
	}
	for (const prefix of [
		"exec:",
		"python:",
		"golang:"
	]) if (id.startsWith(prefix)) {
		const filePath = id.slice(prefix.length);
		if (filePath.includes("/") || filePath.includes("\\")) return `${prefix}${path$1.resolve(filePath)}`;
		return id;
	}
	if ((id.endsWith(".js") || id.endsWith(".ts") || id.endsWith(".mjs")) && (id.includes("/") || id.includes("\\"))) return `file://${path$1.resolve(id)}`;
	return id;
}
function getProviderLabel(provider) {
	return provider?.label && typeof provider.label === "string" ? provider.label : void 0;
}
function providerToIdentifier(provider) {
	if (!provider) return;
	if (typeof provider === "string") return canonicalizeProviderId(provider);
	const label = getProviderLabel(provider);
	if (label) return label;
	if (isApiProvider(provider)) return canonicalizeProviderId(provider.id());
	if (isProviderOptions(provider)) {
		if (provider.id) return canonicalizeProviderId(provider.id);
		return;
	}
	if (typeof provider === "object" && "id" in provider && typeof provider.id === "string") return canonicalizeProviderId(provider.id);
}
/**
* Gets a descriptive identifier string for a provider, showing both label and ID when both exist.
* Useful for error messages to help users debug provider reference issues.
*/
function getProviderDescription(provider) {
	const label = provider.label;
	const id = provider.id();
	if (label && label !== id) return `${label} (${id})`;
	return id;
}
/**
* Checks if a provider reference matches a given provider.
* Supports exact matching and wildcard patterns.
*/
function doesProviderRefMatch(ref, provider) {
	const label = provider.label;
	const id = provider.id();
	const canonicalRef = canonicalizeProviderId(ref);
	const canonicalId = canonicalizeProviderId(id);
	if (label && label === ref) return true;
	if (id === ref || canonicalId === canonicalRef) return true;
	if (ref.endsWith("*")) {
		const prefix = ref.slice(0, -1);
		if (label?.startsWith(prefix) || id.startsWith(prefix) || canonicalId.startsWith(prefix)) return true;
	}
	if (label?.startsWith(`${ref}:`) || id.startsWith(`${ref}:`) || canonicalId.startsWith(`${ref}:`)) return true;
	return false;
}
/**
* Checks if a provider is allowed based on a list of allowed references.
*/
function isProviderAllowed(provider, allowedProviders) {
	if (!Array.isArray(allowedProviders)) return true;
	if (allowedProviders.length === 0) return false;
	return allowedProviders.some((ref) => doesProviderRefMatch(ref, provider));
}
/**
* Detects if a provider uses OpenAI models.
* This includes direct OpenAI providers and Azure OpenAI.
*/
function isOpenAiProvider(providerId) {
	const lowerProviderId = providerId.toLowerCase();
	if (lowerProviderId.startsWith("openai:")) return true;
	if (lowerProviderId.startsWith("azureopenai:")) return true;
	if (lowerProviderId.startsWith("azure:")) {
		if ([
			"gpt",
			"openai",
			"davinci",
			"curie",
			"babbage",
			"ada",
			"text-embedding",
			"whisper",
			"dall-e",
			"tts"
		].some((indicator) => lowerProviderId.includes(indicator))) return true;
	}
	return false;
}
/**
* Detects if a provider uses Anthropic/Claude models.
* This includes direct Anthropic providers, Bedrock with Claude, and Vertex with Claude.
*/
function isAnthropicProvider(providerId) {
	const lowerProviderId = providerId.toLowerCase();
	if (lowerProviderId.startsWith("anthropic:")) return true;
	if (lowerProviderId.startsWith("bedrock:")) {
		if (lowerProviderId.includes("claude") || lowerProviderId.includes("anthropic")) return true;
	}
	if (lowerProviderId.startsWith("vertex:")) {
		if (lowerProviderId.includes("claude")) return true;
	}
	return false;
}
/**
* Detects if a provider uses Google models.
* This includes direct Google/Vertex providers with Gemini and other Google models.
* Note: Vertex with Claude models is NOT counted as Google (it's Anthropic).
*/
function isGoogleProvider(providerId) {
	const lowerProviderId = providerId.toLowerCase();
	if (lowerProviderId.startsWith("google:")) return true;
	if (lowerProviderId.startsWith("vertex:")) {
		if (!lowerProviderId.includes("claude")) return true;
	}
	return false;
}

//#endregion
//#region src/util/comparison.ts
/**
* Explicit runtime variable names that don't follow the underscore convention.
* These are added during evaluation but aren't part of the original test definition.
*
* - sessionId: Added by multi-turn strategy providers (GOAT, Crescendo)
*
* Note: Variables starting with underscore (e.g., _conversation) are automatically
* treated as runtime variables and filtered out.
*/
const EXPLICIT_RUNTIME_VAR_KEYS = ["sessionId"];
/**
* Checks if a variable key is a runtime-only variable that should be filtered
* when comparing test cases.
*
* Runtime variables are identified by:
* 1. Starting with underscore (_) - convention for internal/runtime vars
* 2. Being in the explicit runtime var list (for legacy vars like sessionId)
*/
function isRuntimeVar(key) {
	return key.startsWith("_") || EXPLICIT_RUNTIME_VAR_KEYS.includes(key);
}
/**
* Filters out runtime-only variables that are added during evaluation
* but aren't part of the original test definition.
*
* This is used when comparing test cases to determine if a result
* corresponds to a particular test, regardless of runtime state.
*
* Runtime variables are identified by:
* - Starting with underscore (e.g., _conversation, _metadata)
* - Being in the explicit list (e.g., sessionId for backward compatibility)
*/
function filterRuntimeVars(vars) {
	if (!vars) return vars;
	const filtered = {};
	for (const [key, value] of Object.entries(vars)) if (!isRuntimeVar(key)) filtered[key] = value;
	return filtered;
}
function varsMatch(vars1, vars2) {
	return deepEqual(vars1, vars2);
}
/**
* Generate a unique key for a test case for deduplication purposes.
* Excludes runtime variables and includes strategyId to distinguish tests
* with the same prompt but different strategies.
*
* @param testCase - The test case to generate a key for
* @returns A JSON string that uniquely identifies the test case
*/
function getTestCaseDeduplicationKey(testCase) {
	const filteredVars = filterRuntimeVars(testCase.vars);
	const strategyId = testCase.metadata?.strategyId || "none";
	return JSON.stringify({
		vars: filteredVars,
		strategyId
	});
}
/**
* Deduplicates an array of test cases based on their vars and strategyId.
* Tests with the same vars but different strategies are considered different.
* Runtime variables (like _conversation, sessionId) are filtered out before comparison.
*
* @param tests - Array of test cases to deduplicate
* @returns Deduplicated array of test cases
*/
function deduplicateTestCases(tests) {
	const seen = /* @__PURE__ */ new Set();
	return tests.filter((test) => {
		const key = getTestCaseDeduplicationKey(test);
		if (seen.has(key)) return false;
		seen.add(key);
		return true;
	});
}
function resultIsForTestCase(result, testCase) {
	const testProviderId = testCase.provider ? providerToIdentifier(testCase.provider) : void 0;
	const resultProviderId = providerToIdentifier(result.provider);
	const providersMatch = !testProviderId || !resultProviderId || testProviderId === resultProviderId;
	const resultVars = filterRuntimeVars(result.vars);
	const testVars = filterRuntimeVars(testCase.vars);
	const doVarsMatch = varsMatch(testVars, resultVars);
	const isMatch = doVarsMatch && providersMatch;
	if (!isMatch) {
		const varKeys = testVars ? Object.keys(testVars).join(", ") : "none";
		logger_default.debug(`[resultIsForTestCase] No match: vars=${doVarsMatch}, providers=${providersMatch}`, {
			testProvider: testProviderId || "none",
			resultProvider: resultProviderId || "none",
			testVarKeys: varKeys
		});
	}
	return isMatch;
}

//#endregion
//#region src/util/env.ts
/**
* Load environment variables from .env file(s).
* @param envPath - Single path, array of paths, or undefined for default .env loading.
*                  When paths are explicitly specified, all files must exist or an error is thrown.
*                  When multiple files are provided, later files override values from earlier files.
*/
function setupEnv(envPath) {
	if (envPath) {
		const paths = (Array.isArray(envPath) ? envPath : [envPath]).flatMap((p) => p.includes(",") ? p.split(",").map((s) => s.trim()) : p.trim()).filter((p) => p.length > 0);
		if (paths.length === 0) {
			dotenv.config({ quiet: true });
			return;
		}
		for (const p of paths) if (!fs$2.existsSync(p)) throw new Error(`Environment file not found: ${p}`);
		if (paths.length === 1) logger_default.info(`Loading environment variables from ${paths[0]}`);
		else logger_default.info(`Loading environment variables from: ${paths.join(", ")}`);
		const pathArg = paths.length === 1 ? paths[0] : paths;
		dotenv.config({
			path: pathArg,
			override: true,
			quiet: true
		});
	} else dotenv.config({ quiet: true });
}

//#endregion
//#region src/util/functions/loadFunction.ts
const functionCache = {};
/**
* Loads a function from a JavaScript or Python file
* @param options Options for loading the function
* @returns The loaded function
*/
async function loadFunction({ filePath, functionName, defaultFunctionName = "func", basePath = cliState_default.basePath, useCache = true }) {
	const cacheKey = `${filePath}${functionName ? `:${functionName}` : ""}`;
	if (useCache && functionCache[cacheKey]) return functionCache[cacheKey];
	const resolvedPath = basePath ? path.resolve(basePath, filePath) : filePath;
	if (!isJavascriptFile(resolvedPath) && !resolvedPath.endsWith(".py")) throw new Error(`File must be a JavaScript (${JAVASCRIPT_EXTENSIONS.join(", ")}) or Python (.py) file`);
	try {
		let func;
		if (isJavascriptFile(resolvedPath)) {
			const module = await importModule(resolvedPath, functionName);
			let moduleFunc;
			if (functionName) moduleFunc = module;
			else moduleFunc = typeof module === "function" ? module : module?.default?.default || module?.default || module?.[defaultFunctionName] || module;
			if (typeof moduleFunc !== "function") throw new Error(functionName ? `JavaScript file must export a "${functionName}" function` : `JavaScript file must export a function (as default export or named export "${defaultFunctionName}")`);
			func = moduleFunc;
		} else {
			const result = (...args) => runPython(resolvedPath, functionName || defaultFunctionName, args);
			func = result;
		}
		if (useCache) functionCache[cacheKey] = func;
		return func;
	} catch (err) {
		logger_default.error(`Failed to load function: ${err.message}`);
		throw err;
	}
}
/**
* Extracts the file path and function name from a file:// URL
* @param fileUrl The file:// URL (e.g., "file://path/to/file.js:functionName")
* @returns The file path and optional function name
*/
function parseFileUrl(fileUrl) {
	if (!fileUrl.startsWith("file://")) throw new Error("URL must start with file://");
	const urlWithoutProtocol = fileUrl.slice(7);
	const lastColonIndex = urlWithoutProtocol.lastIndexOf(":");
	if (lastColonIndex > 1) return {
		filePath: urlWithoutProtocol.slice(0, lastColonIndex),
		functionName: urlWithoutProtocol.slice(lastColonIndex + 1)
	};
	return { filePath: urlWithoutProtocol };
}

//#endregion
//#region src/util/templates.ts
/**
* Get a Nunjucks engine instance with optional filters and configuration.
* @param filters - Optional map of custom Nunjucks filters.
* @param throwOnUndefined - Whether to throw an error on undefined variables.
* @param isGrader - Whether this engine is being used in a grader context.
* Nunjucks is always enabled in grader mode.
* @returns A configured Nunjucks environment.
*/
function getNunjucksEngine(filters, throwOnUndefined = false, isGrader = false) {
	if (!isGrader && getEnvBool("PROMPTFOO_DISABLE_TEMPLATING")) return { renderString: (template) => template };
	const env = nunjucks.configure({
		autoescape: false,
		throwOnUndefined
	});
	const envGlobals = {
		...getEnvBool("PROMPTFOO_DISABLE_TEMPLATE_ENV_VARS", getEnvBool("PROMPTFOO_SELF_HOSTED", false)) ? {} : process.env,
		...cliState_default.config?.env
	};
	env.addGlobal("env", envGlobals);
	env.addFilter("load", function(str) {
		return JSON.parse(str);
	});
	if (filters) for (const [name, filter] of Object.entries(filters)) env.addFilter(name, filter);
	return env;
}
/**
* Parse Nunjucks template to extract variables.
* @param template - The Nunjucks template string.
* @returns An array of variables used in the template.
*/
function extractVariablesFromTemplate(template) {
	const variableSet = /* @__PURE__ */ new Set();
	const regex = /\{\{[\s]*([^{}\s|]+)[\s]*(?:\|[^}]+)?\}\}|\{%[\s]*(?:if|for)[\s]+([^{}\s]+)[\s]*.*?%\}/g;
	template = template.replace(/\{#[\s\S]*?#\}/g, "");
	let match;
	while ((match = regex.exec(template)) !== null) {
		const variable = match[1] || match[2];
		if (variable) variableSet.add(variable);
	}
	const forLoopRegex = /\{%[\s]*for[\s]+(\w+)[\s]+in[\s]+(\w+)[\s]*%\}/g;
	while ((match = forLoopRegex.exec(template)) !== null) {
		variableSet.delete(match[1]);
		variableSet.add(match[2]);
	}
	return Array.from(variableSet);
}
/**
* Extract variables from multiple Nunjucks templates.
* @param templates - An array of Nunjucks template strings.
* @returns An array of variables used in the templates.
*/
function extractVariablesFromTemplates(templates) {
	const variableSet = /* @__PURE__ */ new Set();
	for (const template of templates) extractVariablesFromTemplate(template).forEach((variable) => variableSet.add(variable));
	return Array.from(variableSet);
}

//#endregion
//#region src/util/render.ts
/**
* Renders ONLY environment variable templates in an object, leaving all other templates untouched.
* This allows env vars to be resolved at provider load time while preserving runtime var templates.
*
* Supports full Nunjucks syntax for env vars including filters and expressions:
* - {{ env.VAR_NAME }}
* - {{ env['VAR-NAME'] }}
* - {{ env["VAR-NAME"] }}
* - {{ env.VAR | default('fallback') }}
* - {{ env.VAR | upper }}
*
* Preserves non-env templates for runtime rendering:
* - {{ vars.x }} - preserved as literal
* - {{ prompt }} - preserved as literal
*
* Implementation: Uses regex to find env templates, delegates to Nunjucks for rendering.
* This ensures full Nunjucks feature support while preserving non-env templates.
*
* @param obj - The object to process
* @param envOverrides - Optional env vars to merge with (or replace) the base env
* @param replaceBase - If true, envOverrides replaces the base env entirely instead of merging
* @returns The object with only env templates rendered
*/
function renderEnvOnlyInObject(obj, envOverrides, replaceBase) {
	if (getEnvBool("PROMPTFOO_DISABLE_TEMPLATING")) return obj;
	if (typeof obj === "string") {
		if (obj.length > 5e4) {
			logger_default.warn(`String too long (${obj.length} chars) for template matching. Skipping env var rendering.`);
			return obj;
		}
		const nunjucks = getNunjucksEngine();
		const baseEnvGlobals = nunjucks.getGlobal("env");
		const envGlobals = replaceBase ? envOverrides ?? {} : envOverrides ? {
			...baseEnvGlobals,
			...envOverrides
		} : baseEnvGlobals;
		return obj.replace(/\{\{(?:[^}]|\}(?!\}))*\}\}/g, (match) => {
			if (!match.match(/\benv\.|env\[/)) return match;
			const varMatch = match.match(/env\.(\w+)|env\[['"]([^'"]+)['"]\]/);
			const varName = varMatch?.[1] || varMatch?.[2];
			if (match.includes("|") || varName && varName in envGlobals && envGlobals[varName] !== void 0) try {
				return nunjucks.renderString(match, { env: envGlobals });
			} catch (error) {
				logger_default.debug(`Failed to render env template "${match}": ${error instanceof Error ? error.message : String(error)}`);
				return match;
			}
			return match;
		});
	}
	if (Array.isArray(obj)) return obj.map((item) => renderEnvOnlyInObject(item, envOverrides, replaceBase));
	if (typeof obj === "object" && obj !== null) {
		const result = {};
		for (const key in obj) result[key] = renderEnvOnlyInObject(obj[key], envOverrides, replaceBase);
		return result;
	}
	return obj;
}
function renderVarsInObject(obj, vars) {
	if (!vars || getEnvBool("PROMPTFOO_DISABLE_TEMPLATING")) return obj;
	if (typeof obj === "string") return getNunjucksEngine().renderString(obj, vars);
	if (Array.isArray(obj)) return obj.map((item) => renderVarsInObject(item, vars));
	if (typeof obj === "object" && obj !== null) {
		const result = {};
		for (const key in obj) result[key] = renderVarsInObject(obj[key], vars);
		return result;
	} else if (typeof obj === "function") return renderVarsInObject(obj({ vars }));
	return obj;
}

//#endregion
//#region src/util/file.ts
/**
* Simple Nunjucks engine specifically for file paths
* This function is separate from the main getNunjucksEngine to avoid circular dependencies
*/
function getNunjucksEngineForFilePath() {
	const env = nunjucks.configure({ autoescape: false });
	env.addGlobal("env", {
		...process.env,
		...cliState_default.config?.env
	});
	return env;
}
/**
* Loads content from an external file if the input is a file path, otherwise
* returns the input as-is. Supports Nunjucks templating for file paths.
*
* @param filePath - The input to process. Can be a file path string starting with "file://",
* an array of file paths, or any other type of data.
* @param context - Optional context to control file loading behavior. 'assertion' context
* preserves Python/JS file references instead of loading their content.
* @returns The loaded content if the input was a file path, otherwise the original input.
* For JSON and YAML files, the content is parsed into an object.
* For other file types, the raw file content is returned as a string.
*
* @throws {Error} If the specified file does not exist.
*/
function maybeLoadFromExternalFile(filePath, context) {
	if (Array.isArray(filePath)) return filePath.map((path) => {
		return maybeLoadFromExternalFile(path, context);
	});
	if (typeof filePath !== "string") return filePath;
	if (!filePath.startsWith("file://")) return filePath;
	const renderedFilePath = getNunjucksEngineForFilePath().renderString(filePath, {});
	const { filePath: cleanPath, functionName } = parseFileUrl(renderedFilePath);
	if (context === "assertion" && (cleanPath.endsWith(".py") || isJavascriptFile(cleanPath))) {
		logger_default.debug(`Preserving Python/JS file reference in assertion context: ${renderedFilePath}`);
		return renderedFilePath;
	}
	if (context === "vars") {
		logger_default.debug(`Preserving file reference in vars context: ${renderedFilePath}`);
		return renderedFilePath;
	}
	if (functionName && (cleanPath.endsWith(".py") || isJavascriptFile(cleanPath))) return renderedFilePath;
	const pathToUse = functionName && !(cleanPath.endsWith(".py") || isJavascriptFile(cleanPath)) ? renderedFilePath.slice(7) : cleanPath;
	const resolvedPath = path$1.resolve(cliState_default.basePath || "", pathToUse);
	if (hasMagic(pathToUse)) {
		const matchedFiles = globSync(resolvedPath, { windowsPathsNoEscape: true });
		if (matchedFiles.length === 0) throw new Error(`No files found matching pattern: ${resolvedPath}`);
		const allContents = [];
		for (const matchedFile of matchedFiles) {
			let contents;
			try {
				contents = fs$2.readFileSync(matchedFile, "utf8");
			} catch (error) {
				if (error.code === "ENOENT") {
					logger_default.debug(`File disappeared during glob expansion: ${matchedFile}`);
					continue;
				}
				throw error;
			}
			if (matchedFile.endsWith(".json")) {
				const parsed = JSON.parse(contents);
				if (Array.isArray(parsed)) allContents.push(...parsed);
				else allContents.push(parsed);
			} else if (matchedFile.endsWith(".yaml") || matchedFile.endsWith(".yml")) {
				const parsed = yaml.load(contents);
				if (parsed === null || parsed === void 0) continue;
				if (Array.isArray(parsed)) allContents.push(...parsed);
				else allContents.push(parsed);
			} else if (matchedFile.endsWith(".csv")) {
				const records = parse$1(contents, { columns: true });
				if (records.length > 0 && Object.keys(records[0]).length === 1) allContents.push(...records.map((record) => Object.values(record)[0]));
				else allContents.push(...records);
			} else allContents.push(contents);
		}
		return allContents;
	}
	const finalPath = resolvedPath;
	let contents;
	try {
		contents = fs$2.readFileSync(finalPath, "utf8");
	} catch (error) {
		if (error.code === "ENOENT") throw new Error(`File does not exist: ${finalPath}`);
		throw new Error(`Failed to read file ${finalPath}: ${error}`);
	}
	if (finalPath.endsWith(".json")) try {
		return JSON.parse(contents);
	} catch (error) {
		throw new Error(`Failed to parse JSON file ${finalPath}: ${error}`);
	}
	if (finalPath.endsWith(".yaml") || finalPath.endsWith(".yml")) try {
		return yaml.load(contents);
	} catch (error) {
		throw new Error(`Failed to parse YAML file ${finalPath}: ${error}`);
	}
	if (finalPath.endsWith(".csv")) {
		const records = parse$1(contents, { columns: true });
		if (records.length > 0 && Object.keys(records[0]).length === 1) return records.map((record) => Object.values(record)[0]);
		return records;
	}
	return contents;
}
/**
* Resolves a relative file path with respect to a base path, handling cloud configuration appropriately.
* When using a cloud configuration, the current working directory is always used instead of the context's base path.
*
* @param filePath - The relative or absolute file path to resolve.
* @param isCloudConfig - Whether this is a cloud configuration.
* @returns The resolved absolute file path.
*/
function getResolvedRelativePath(filePath, isCloudConfig) {
	if (path$1.isAbsolute(filePath) || !isCloudConfig) return filePath;
	return path$1.join(process.cwd(), filePath);
}
/**
* Recursively loads external file references from a configuration object.
*
* @param config - The configuration object to process
* @param context - Optional context to control file loading behavior
* @returns The configuration with external file references resolved
*/
function maybeLoadConfigFromExternalFile(config, context) {
	if (Array.isArray(config)) return config.map((item) => maybeLoadConfigFromExternalFile(item, context));
	if (config && typeof config === "object" && config !== null) {
		const result = {};
		for (const key of Object.keys(config)) {
			const childContext = key === "value" && typeof config === "object" && config && "type" in config && typeof config.type === "string" && (config.type === "python" || config.type === "javascript") ? "assertion" : key === "vars" ? "vars" : context;
			result[key] = maybeLoadConfigFromExternalFile(config[key], childContext);
		}
		return result;
	}
	return maybeLoadFromExternalFile(config, context);
}
/**
* Parses a file path or glob pattern to extract function names and file extensions.
* Function names can be specified in the filename like this:
* prompt.py:myFunction or prompts.js:myFunction.
* @param basePath - The base path for file resolution.
* @param promptPath - The path or glob pattern.
* @returns Parsed details including function name, file extension, and directory status.
*/
function parsePathOrGlob(basePath, promptPath) {
	if (promptPath.startsWith("file://")) promptPath = promptPath.slice(7);
	const filePath = path$1.resolve(basePath, promptPath);
	let filename = path$1.relative(basePath, filePath);
	let functionName;
	if (filename.includes(":")) {
		const lastColonIndex = filename.lastIndexOf(":");
		if (lastColonIndex > 1) {
			const pathWithoutFunction = filename.slice(0, lastColonIndex);
			if (isJavascriptFile(pathWithoutFunction) || pathWithoutFunction.endsWith(".py") || pathWithoutFunction.endsWith(".go") || pathWithoutFunction.endsWith(".rb")) {
				functionName = filename.slice(lastColonIndex + 1);
				filename = pathWithoutFunction;
			}
		}
	}
	let stats;
	try {
		stats = fs$2.statSync(path$1.join(basePath, filename));
	} catch (err) {
		if (getEnvBool("PROMPTFOO_STRICT_FILES")) throw err;
	}
	const normalizedFilePath = filePath.replace(/\\/g, "/");
	const isPathPattern = stats?.isDirectory() || hasMagic(promptPath) || hasMagic(normalizedFilePath);
	const safeFilename = path$1.relative(basePath, safeResolve(basePath, filename));
	return {
		extension: isPathPattern ? void 0 : path$1.parse(safeFilename).ext,
		filePath: path$1.join(basePath, safeFilename),
		functionName,
		isPathPattern
	};
}
function readOutput(outputPath) {
	const ext = path$1.parse(outputPath).ext.slice(1);
	switch (ext) {
		case "json": return JSON.parse(fs$2.readFileSync(outputPath, "utf-8"));
		default: throw new Error(`Unsupported output file format: ${ext} currently only supports json`);
	}
}
/**
* Load custom Nunjucks filters from external files.
* Note: If a glob pattern matches multiple files, only the last file's export is used.
* Each filter name should typically resolve to a single file.
*/
async function readFilters(filters, basePath = "") {
	const ret = {};
	for (const [name, filterPath] of Object.entries(filters)) {
		const filePaths = globSync(path$1.join(basePath, filterPath), { windowsPathsNoEscape: true });
		for (const filePath of filePaths) ret[name] = await importModule(path$1.resolve(filePath));
	}
	return ret;
}
/**
* Loads configuration from an external file with variable rendering.
* This is a convenience wrapper that combines renderVarsInObject and maybeLoadFromExternalFile.
*
* Use this for simple config fields that:
* - Need variable rendering ({{ vars.x }}, {{ env.X }})
* - May reference external files (file://path.json)
* - Don't have nested file references that need loading
*
* For fields with nested file references (like response_format.schema),
* use maybeLoadResponseFormatFromExternalFile instead.
*
* @param config - The configuration to process
* @param vars - Variables for template rendering
* @returns The processed configuration with variables rendered and files loaded
*/
function maybeLoadFromExternalFileWithVars(config, vars) {
	return maybeLoadFromExternalFile(renderVarsInObject(config, vars));
}
/**
* Loads response_format configuration from an external file with variable rendering.
*
* This function handles the special case where response_format may contain:
* 1. A top-level file reference (file://format.json)
* 2. A nested schema reference for json_schema type (schema: file://schema.json)
*
* Both levels need variable rendering and file loading.
*
* @param responseFormat - The response_format configuration
* @param vars - Variables for template rendering
* @returns The processed response_format with all files loaded
*/
function maybeLoadResponseFormatFromExternalFile(responseFormat, vars) {
	if (responseFormat === void 0 || responseFormat === null) return responseFormat;
	const loaded = maybeLoadFromExternalFile(renderVarsInObject(responseFormat, vars));
	if (!loaded || typeof loaded !== "object") return loaded;
	if (loaded.type === "json_schema") {
		const nestedSchema = loaded.schema || loaded.json_schema?.schema;
		if (nestedSchema) {
			const loadedSchema = maybeLoadFromExternalFile(renderVarsInObject(nestedSchema, vars));
			if (loaded.schema !== void 0) return {
				...loaded,
				schema: loadedSchema
			};
			else if (loaded.json_schema?.schema !== void 0) return {
				...loaded,
				json_schema: {
					...loaded.json_schema,
					schema: loadedSchema
				}
			};
		}
	}
	return loaded;
}
/**
* Renders variables in a tools object and loads from external file if applicable.
* This function combines renderVarsInObject and maybeLoadFromExternalFile into a single step
* specifically for handling tools configurations.
*
* Supports loading from JSON, YAML, Python, and JavaScript files.
*
* @param tools - The tools configuration object or array to process.
* @param vars - Variables to use for rendering.
* @returns The processed tools configuration with variables rendered and content loaded from files if needed.
* @throws {Error} If the loaded tools are in an invalid format
*/
async function maybeLoadToolsFromExternalFile(tools, vars) {
	const rendered = renderVarsInObject(tools, vars);
	if (typeof rendered === "string" && rendered.startsWith("file://")) {
		const { filePath, functionName } = parseFileUrl(rendered);
		if (functionName && (filePath.endsWith(".py") || isJavascriptFile(filePath))) {
			const fileType = filePath.endsWith(".py") ? "Python" : "JavaScript";
			logger_default.debug(`[maybeLoadToolsFromExternalFile] Loading tools from ${fileType} file: ${filePath}:${functionName}`);
			try {
				let toolDefinitions;
				if (filePath.endsWith(".py")) {
					const absPath = safeResolve(cliState_default.basePath || process.cwd(), filePath);
					logger_default.debug(`[maybeLoadToolsFromExternalFile] Resolved Python path: ${absPath}`);
					toolDefinitions = await runPython(absPath, functionName, []);
				} else {
					const absPath = safeResolve(cliState_default.basePath || process.cwd(), filePath);
					logger_default.debug(`[maybeLoadToolsFromExternalFile] Resolved JavaScript path: ${absPath}`);
					const module = await importModule(absPath);
					const fn = module[functionName] || module.default?.[functionName];
					if (typeof fn !== "function") {
						const availableExports = Object.keys(module).filter((k) => k !== "default");
						const basePath = cliState_default.basePath || process.cwd();
						throw new Error(`Function "${functionName}" not found in ${filePath}. Available exports: ${availableExports.length > 0 ? availableExports.join(", ") : "(none)"}\nResolved from: ${basePath}`);
					}
					toolDefinitions = await Promise.resolve(fn());
				}
				if (!toolDefinitions || typeof toolDefinitions === "string" || typeof toolDefinitions === "number" || typeof toolDefinitions === "boolean") throw new Error(`Function "${functionName}" must return an array or object of tool definitions, but returned: ${toolDefinitions === null ? "null" : typeof toolDefinitions}`);
				logger_default.debug(`[maybeLoadToolsFromExternalFile] Successfully loaded ${Array.isArray(toolDefinitions) ? toolDefinitions.length : "object"} tools`);
				return toolDefinitions;
			} catch (err) {
				const errorMessage = err instanceof Error ? err.message : String(err);
				const basePath = cliState_default.basePath || process.cwd();
				throw new Error(`Failed to load tools from ${rendered}:\n${errorMessage}\n\nMake sure the function "${functionName}" exists and returns a valid tool definition array.\nResolved from: ${basePath}`);
			}
		}
		if (filePath.endsWith(".py") || isJavascriptFile(filePath)) {
			const ext = filePath.endsWith(".py") ? "Python" : "JavaScript";
			const basePath = cliState_default.basePath || process.cwd();
			throw new Error(`Cannot load tools from ${rendered}\n${ext} files require a function name. Use this format:\n  tools: file://${filePath}:get_tools\n\nYour ${ext} file should export a function that returns tool definitions:\n` + (filePath.endsWith(".py") ? `  def get_tools():\n      return [{"type": "function", "function": {...}}]` : `  module.exports.get_tools = () => [{ type: "function", function: {...} }];`) + `\n\nResolved from: ${basePath}`);
		}
	}
	if (Array.isArray(rendered)) {
		const results = await Promise.all(rendered.map((item) => maybeLoadToolsFromExternalFile(item, vars)));
		if (results.every((r) => Array.isArray(r))) return results.flat();
		return results;
	}
	if (typeof rendered !== "string") return rendered;
	const loaded = maybeLoadFromExternalFile(rendered);
	if (loaded !== void 0 && loaded !== null && typeof loaded === "string") {
		if (loaded.startsWith("file://")) throw new Error(`Failed to load tools from ${loaded}\nEnsure the file exists and contains valid JSON or YAML tool definitions.`);
		if (loaded.includes("def ") || loaded.includes("import ")) throw new Error("Invalid tools configuration: file appears to contain Python code.\nPython files require a function name. Use this format:\n  tools: file://tools.py:get_tools");
		throw new Error("Invalid tools configuration: expected an array or object, but got a string.\nIf using file://, ensure the file contains valid JSON or YAML tool definitions.");
	}
	return loaded;
}

//#endregion
//#region src/googleSheets.ts
async function checkGoogleSheetAccess(url) {
	try {
		const response = await fetchWithProxy(url);
		if (response.ok) return {
			public: true,
			status: response.status
		};
		else return {
			public: false,
			status: response.status
		};
	} catch (error) {
		logger_default.error(`Error checking sheet access: ${error}`);
		return { public: false };
	}
}
async function fetchCsvFromGoogleSheetUnauthenticated(url) {
	const { parse: parseCsv } = await import("csv-parse/sync");
	const gid = new URL(url).searchParams.get("gid");
	const response = await fetchWithProxy(`${url.replace(/\/edit.*$/, "/export")}?format=csv${gid ? `&gid=${gid}` : ""}`);
	if (response.status !== 200) throw new Error(`Failed to fetch CSV from Google Sheets URL: ${url}`);
	return parseCsv(await response.text(), { columns: true });
}
async function fetchCsvFromGoogleSheetAuthenticated(url) {
	const { sheets: googleSheets, auth: googleAuth } = await import("@googleapis/sheets");
	const auth = new googleAuth.GoogleAuth({ scopes: ["https://www.googleapis.com/auth/spreadsheets.readonly"] });
	const sheets = googleSheets("v4");
	const match = url.match(/\/d\/([^/]+)/);
	if (!match) throw new Error(`Invalid Google Sheets URL: ${url}`);
	const spreadsheetId = match[1];
	let range;
	const gid = Number(new URL(url).searchParams.get("gid"));
	if (gid) {
		const sheet = (await sheets.spreadsheets.get({
			spreadsheetId,
			auth
		})).data.sheets?.find((sheet) => sheet.properties?.sheetId === gid);
		if (!sheet || !sheet.properties?.title) throw new Error(`Sheet not found for gid: ${gid}`);
		range = sheet.properties.title;
	} else {
		const firstSheet = (await sheets.spreadsheets.get({
			spreadsheetId,
			auth
		})).data.sheets?.[0];
		if (!firstSheet || !firstSheet.properties?.title) throw new Error(`No sheets found in spreadsheet`);
		range = firstSheet.properties.title;
	}
	const rows = (await sheets.spreadsheets.values.get({
		spreadsheetId,
		range,
		auth
	})).data.values;
	if (!rows?.length) throw new Error(`No data found in Google Sheets URL: ${url}`);
	const headers = rows[0];
	return rows.slice(1).map((row) => {
		const csvRow = {};
		headers.forEach((header, index) => {
			csvRow[header] = row[index] ?? "";
		});
		return csvRow;
	});
}
async function fetchCsvFromGoogleSheet(url) {
	const { public: isPublic } = await checkGoogleSheetAccess(url);
	logger_default.debug(`Google Sheets URL: ${url}, isPublic: ${isPublic}`);
	if (isPublic) return fetchCsvFromGoogleSheetUnauthenticated(url);
	return fetchCsvFromGoogleSheetAuthenticated(url);
}
async function writeCsvToGoogleSheet(rows, url) {
	const { sheets: googleSheets, auth: googleAuth } = await import("@googleapis/sheets");
	const auth = new googleAuth.GoogleAuth({ scopes: ["https://www.googleapis.com/auth/spreadsheets"] });
	const sheets = googleSheets("v4");
	const match = url.match(/\/d\/([^/]+)/);
	if (!match) throw new Error(`Invalid Google Sheets URL: ${url}`);
	const spreadsheetId = match[1];
	const headers = Object.keys(rows[0]);
	const values = [headers, ...rows.map((row) => headers.map((header) => row[header]))];
	const getColumnLetter = (col) => {
		let letter = "";
		while (col > 0) {
			col--;
			letter = String.fromCharCode(65 + col % 26) + letter;
			col = Math.floor(col / 26);
		}
		return letter;
	};
	const numRows = values.length;
	const numCols = headers.length;
	const endColumn = getColumnLetter(numCols);
	let range;
	const gid = Number(new URL(url).searchParams.get("gid"));
	if (gid) {
		const sheet = (await sheets.spreadsheets.get({
			spreadsheetId,
			auth
		})).data.sheets?.find((sheet) => sheet.properties?.sheetId === gid);
		if (!sheet || !sheet.properties?.title) throw new Error(`Sheet not found for gid: ${gid}`);
		range = `${sheet.properties.title}!A1:${endColumn}${numRows}`;
	} else {
		const newSheetTitle = `Sheet${Date.now()}`;
		await sheets.spreadsheets.batchUpdate({
			spreadsheetId,
			auth,
			requestBody: { requests: [{ addSheet: { properties: { title: newSheetTitle } } }] }
		});
		range = `${newSheetTitle}!A1:${endColumn}${numRows}`;
	}
	logger_default.debug(`Writing CSV to Google Sheets URL: ${url} with ${values.length} rows`);
	await sheets.spreadsheets.values.update({
		spreadsheetId,
		range,
		valueInputOption: "USER_ENTERED",
		auth,
		requestBody: { values }
	});
}

//#endregion
//#region src/server/utils/evalTableUtils.ts
/**
* Error thrown when a comparison eval is not found.
*/
var ComparisonEvalNotFoundError = class extends Error {
	constructor(evalId) {
		super(`Comparison eval not found: ${evalId}`);
		this.name = "ComparisonEvalNotFoundError";
	}
};
/**
*
*
*
* Keep this in it's current order, as it is used to map the columns in the CSV, so it needs to be static.
*
*
* The keys are the names of the columns in the metadata object, and the values are the names of the columns in the CSV.
*
* This is imported by enterprise so it doesn't need to be copied.
*
*/
const REDTEAM_METADATA_KEYS_TO_CSV_COLUMN_NAMES = {
	messages: "Messages",
	redteamHistory: "RedteamHistory",
	redteamTreeHistory: "RedteamTreeHistory",
	pluginId: "pluginId",
	strategyId: "strategyId",
	sessionId: "sessionId",
	sessionIds: "sessionIds"
};
const REDTEAM_METADATA_COLUMNS = Object.values(REDTEAM_METADATA_KEYS_TO_CSV_COLUMN_NAMES);
/**
* Get the status string for an output
*/
function getOutputStatus(output) {
	if (output.pass) return "PASS";
	return output.failureReason === ResultFailureReason.ASSERT ? "FAIL" : "ERROR";
}
/**
* Format named scores for CSV output.
* Returns empty string if no named scores, otherwise JSON string.
*/
function formatNamedScores(namedScores) {
	if (!namedScores || Object.keys(namedScores).length === 0) return "";
	const rounded = {};
	for (const [key, value] of Object.entries(namedScores)) if (typeof value === "number" && !Number.isNaN(value)) rounded[key] = Number(value.toFixed(2));
	if (Object.keys(rounded).length === 0) return "";
	return JSON.stringify(rounded);
}
/**
* Build CSV headers for an evaluation table.
*
* @param vars - Variable names from the table head
* @param prompts - Prompt definitions from the table head
* @param options - Export options
* @returns Array of header strings
*/
function buildCsvHeaders(vars, prompts, options = {}) {
	const headers = [
		...options.hasDescriptions ? ["Description"] : [],
		...vars,
		...prompts.flatMap((prompt) => {
			const provider = prompt.provider || "";
			return [
				provider ? `[${provider}] ${prompt.label}` : prompt.label,
				"Status",
				"Score",
				"Named Scores",
				"Grader Reason",
				"Comment"
			];
		})
	];
	if (options.isRedteam) headers.push(...REDTEAM_METADATA_COLUMNS);
	return headers;
}
/**
* Convert a single table row to CSV row values.
*
* @param row - The table row to convert
* @param options - Export options
* @returns Array of values for the CSV row
*/
function tableRowToCsvValues(row, options = {}) {
	const rowValues = [
		...options.hasDescriptions ? [row.test.description || ""] : [],
		...row.vars,
		...row.outputs.flatMap((output) => {
			if (!output) return [
				"",
				"",
				"",
				"",
				"",
				""
			];
			const status = getOutputStatus(output);
			const score = output.score?.toFixed(2) ?? "";
			const namedScores = formatNamedScores(output.namedScores);
			return [
				output.text || "",
				status,
				score,
				namedScores,
				output.gradingResult?.reason || "",
				output.gradingResult?.comment || ""
			];
		})
	];
	if (options.isRedteam) {
		const redteamKeys = Object.keys(REDTEAM_METADATA_KEYS_TO_CSV_COLUMN_NAMES);
		const firstOutputMetadata = row.outputs[0]?.metadata;
		for (const key of redteamKeys) {
			let value = firstOutputMetadata?.[key];
			if (key === "strategyId" && (value === null || value === void 0)) value = "basic";
			if (value === null || value === void 0) rowValues.push("");
			else if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") rowValues.push(value.toString());
			else rowValues.push(JSON.stringify(value));
		}
	}
	return rowValues;
}
/**
* Generates CSV data from evaluation table data.
*
* Column structure per prompt:
* - Output: Pure LLM output text (no pass/fail prefix)
* - Status: PASS | FAIL | ERROR
* - Score: Numeric score (e.g., "1.00")
* - Named Scores: JSON object with per-assertion scores (e.g., {"clarity": 0.90, "accuracy": 0.85})
* - Grader Reason: Explanation from the grader
* - Comment: Additional grader comment
*
* This function is the single source of truth for CSV generation,
* used by both the WebUI export and CLI export.
*
* @param table - The evaluation table data
* @param options - Export options
* @returns CSV formatted string
*/
function evalTableToCsv(table, options = { isRedteam: false }) {
	const { isRedteam } = options;
	const hasDescriptions = table.body.some((row) => row.test.description);
	return stringify([buildCsvHeaders(table.head.vars, table.head.prompts, {
		hasDescriptions,
		isRedteam
	}), ...table.body.map((row) => tableRowToCsvValues(row, {
		hasDescriptions,
		isRedteam
	}))]);
}
/**
* Generate JSON data from evaluation table
* @param table Evaluation table data
* @returns JSON object
*/
function evalTableToJson(table) {
	return table;
}
/**
* Merges comparison tables with the main table for side-by-side CSV export.
*
* @param mainEvalId - The ID of the main evaluation
* @param mainTable - The main evaluation table
* @param comparisonData - Array of comparison eval data (eval ID and table)
* @returns Merged table with all prompts and outputs combined
*/
function mergeComparisonTables(mainEvalId, mainTable, comparisonData) {
	return {
		head: {
			prompts: [...mainTable.head.prompts.map((prompt) => ({
				...prompt,
				label: `[${mainEvalId}] ${prompt.label || ""}`
			})), ...comparisonData.flatMap(({ evalId, table }) => table.head.prompts.map((prompt) => ({
				...prompt,
				label: `[${evalId}] ${prompt.label || ""}`
			})))],
			vars: mainTable.head.vars
		},
		body: mainTable.body.map((row) => {
			const testIdx = row.testIdx;
			const matchingRows = comparisonData.map(({ table }) => table.body.find((compRow) => compRow.testIdx === testIdx)).filter((r) => r !== void 0);
			return {
				...row,
				outputs: [...row.outputs, ...matchingRows.flatMap((r) => r.outputs)]
			};
		})
	};
}
/**
* High-level function to generate CSV from an evaluation.
*
* Used by WebUI for CSV downloads (with or without comparison evals).
* For CLI exports, use `streamEvalCsv` which is more memory-efficient
* for large datasets.
*
* Both functions use the same underlying formatting (`evalTableToCsv`,
* `buildCsvHeaders`, `tableRowToCsvValues`) to ensure consistent output.
*
* @param eval_ - The evaluation to export
* @param options - Export options including filters and comparison eval IDs
* @returns CSV formatted string
* @throws ComparisonEvalNotFoundError if a comparison eval ID is not found
* @throws Error if comparison exports requested without findEvalById callback
*/
async function generateEvalCsv(eval_, options = {}) {
	const UNLIMITED_RESULTS = Number.MAX_SAFE_INTEGER;
	const mainTable = await eval_.getTablePage({
		offset: 0,
		limit: UNLIMITED_RESULTS,
		filterMode: options.filterMode,
		searchQuery: options.searchQuery,
		filters: options.filters
	});
	let finalTable = mainTable;
	if (options.comparisonEvalIds && options.comparisonEvalIds.length > 0) {
		if (!options.findEvalById) throw new Error("findEvalById callback is required for comparison exports. Pass Eval.findById when calling from server routes.");
		const indices = mainTable.body.map((row) => row.testIdx);
		const comparisonData = await Promise.all(options.comparisonEvalIds.map(async (comparisonEvalId) => {
			const comparisonEval = await options.findEvalById(comparisonEvalId);
			if (!comparisonEval) throw new ComparisonEvalNotFoundError(comparisonEvalId);
			const table = await comparisonEval.getTablePage({
				offset: 0,
				limit: indices.length,
				filterMode: "all",
				testIndices: indices,
				searchQuery: options.searchQuery,
				filters: options.filters
			});
			return {
				evalId: comparisonEval.id,
				table
			};
		}));
		finalTable = mergeComparisonTables(eval_.id, mainTable, comparisonData);
	}
	return evalTableToCsv(finalTable, { isRedteam: Boolean(eval_.config.redteam) });
}
/**
* Stream CSV data from an evaluation in batches.
*
* This is more memory-efficient for large evaluations as it processes
* results in batches rather than loading everything into memory.
*
* Used by the CLI export (`promptfoo eval -o output.csv`) to maintain
* consistent CSV format with WebUI exports while handling large datasets.
*
* @param eval_ - The evaluation to export
* @param options - Streaming options including the write callback
*/
async function streamEvalCsv(eval_, options) {
	const { isRedteam = false, write } = options;
	const varNames = eval_.vars;
	const prompts = eval_.prompts;
	const numPrompts = prompts.length;
	let headersWritten = false;
	let hasDescriptions = false;
	let firstBatchBuffer = null;
	for await (const batchResults of eval_.fetchResultsBatched()) {
		const rowsByTestIdx = /* @__PURE__ */ new Map();
		for (const result of batchResults) {
			if (!rowsByTestIdx.has(result.testIdx)) rowsByTestIdx.set(result.testIdx, {
				testIdx: result.testIdx,
				vars: varNames.map((varName) => {
					const value = result.testCase?.vars?.[varName];
					return value !== void 0 ? String(value) : "";
				}),
				outputs: new Array(numPrompts).fill(null),
				test: { description: result.testCase?.description }
			});
			const row = rowsByTestIdx.get(result.testIdx);
			row.outputs[result.promptIdx] = {
				text: result.response?.output ?? "",
				pass: result.success,
				score: result.score,
				namedScores: result.namedScores,
				failureReason: result.failureReason,
				gradingResult: result.gradingResult,
				metadata: result.metadata
			};
		}
		const rows = Array.from(rowsByTestIdx.values());
		if (!headersWritten) {
			hasDescriptions = rows.some((r) => r.test.description);
			await write(stringify([buildCsvHeaders(varNames, prompts, {
				hasDescriptions,
				isRedteam
			})]));
			headersWritten = true;
			if (!hasDescriptions) {
				firstBatchBuffer = rows;
				continue;
			}
		}
		if (firstBatchBuffer !== null) {
			if (rows.some((r) => r.test.description) && !hasDescriptions) {}
			const bufferedCsvRows = firstBatchBuffer.map((row) => tableRowToCsvValues(row, {
				hasDescriptions,
				isRedteam
			}));
			if (bufferedCsvRows.length > 0) await write(stringify(bufferedCsvRows));
			firstBatchBuffer = null;
		}
		const csvRows = rows.map((row) => tableRowToCsvValues(row, {
			hasDescriptions,
			isRedteam
		}));
		if (csvRows.length > 0) await write(stringify(csvRows));
	}
	if (firstBatchBuffer !== null) {
		const bufferedCsvRows = firstBatchBuffer.map((row) => tableRowToCsvValues(row, {
			hasDescriptions,
			isRedteam
		}));
		if (bufferedCsvRows.length > 0) await write(stringify(bufferedCsvRows));
	}
	if (!headersWritten) await write(stringify([buildCsvHeaders(varNames, prompts, {
		hasDescriptions: false,
		isRedteam
	})]));
}

//#endregion
//#region src/util/output.ts
const outputToSimpleString = (output) => {
	const passFailText = output.pass ? "[PASS]" : output.failureReason === ResultFailureReason.ASSERT ? "[FAIL]" : "[ERROR]";
	const namedScoresText = Object.entries(output.namedScores).map(([name, value]) => `${name}: ${value?.toFixed(2)}`).join(", ");
	const scoreText = namedScoresText.length > 0 ? `(${output.score?.toFixed(2)}, ${namedScoresText})` : `(${output.score?.toFixed(2)})`;
	const gradingResultText = output.gradingResult ? `${output.pass ? "Pass" : "Fail"} Reason: ${output.gradingResult.reason}` : "";
	return dedent`
      ${passFailText} ${scoreText}

      ${output.text}

      ${gradingResultText}
    `.trim();
};
function createOutputMetadata(evalRecord) {
	let evaluationCreatedAt;
	if (evalRecord.createdAt) try {
		const date = new Date(evalRecord.createdAt);
		evaluationCreatedAt = Number.isNaN(date.getTime()) ? void 0 : date.toISOString();
	} catch {
		evaluationCreatedAt = void 0;
	}
	return {
		promptfooVersion: VERSION,
		nodeVersion: process.version,
		platform: os$1.platform(),
		arch: os$1.arch(),
		exportedAt: (/* @__PURE__ */ new Date()).toISOString(),
		evaluationCreatedAt,
		author: evalRecord.author
	};
}
/**
* JSON writer with improved error handling for large datasets.
* Provides helpful error messages when memory limits are exceeded.
*/
async function writeJsonOutputSafely(outputPath, evalRecord, shareableUrl) {
	const metadata = createOutputMetadata(evalRecord);
	try {
		const summary = await evalRecord.toEvaluateSummary();
		const outputData = {
			evalId: evalRecord.id,
			results: summary,
			config: evalRecord.config,
			shareableUrl,
			metadata
		};
		const jsonString = JSON.stringify(outputData, null, 2);
		await fsPromises.writeFile(outputPath, jsonString);
	} catch (error) {
		const msg = error?.message ?? "";
		const isStringLen = error instanceof RangeError && msg.includes("Invalid string length");
		const isHeapOOM = /heap out of memory|Array buffer allocation failed|ERR_STRING_TOO_LONG/i.test(msg);
		if (isStringLen || isHeapOOM) {
			const resultCount = await evalRecord.getResultsCount();
			logger_default.error(`Dataset too large for JSON export (${resultCount} results).`);
			throw new Error(`Dataset too large for JSON export. The evaluation has ${resultCount} results which exceeds memory limits. Consider using JSONL format instead: --output output.jsonl`);
		} else throw error;
	}
}
async function writeOutput(outputPath, evalRecord, shareableUrl) {
	if (outputPath.match(/^https:\/\/docs\.google\.com\/spreadsheets\//)) {
		const table = await evalRecord.getTable();
		invariant(table, "Table is required");
		const rows = table.body.map((row) => {
			const csvRow = {};
			table.head.vars.forEach((varName, index) => {
				csvRow[varName] = row.vars[index];
			});
			table.head.prompts.forEach((prompt, index) => {
				csvRow[`[${prompt.provider}] ${prompt.label}`] = outputToSimpleString(row.outputs[index]);
			});
			return csvRow;
		});
		logger_default.info(`Writing ${rows.length} rows to Google Sheets...`);
		await writeCsvToGoogleSheet(rows, outputPath);
		return;
	}
	const { data: outputExtension } = OutputFileExtension.safeParse(path$1.extname(outputPath).slice(1).toLowerCase());
	invariant(outputExtension, `Unsupported output file format ${outputExtension}. Please use one of: ${OutputFileExtension.options.join(", ")}.`);
	const outputDir = path$1.dirname(outputPath);
	await fsPromises.mkdir(outputDir, { recursive: true });
	const metadata = createOutputMetadata(evalRecord);
	if (outputExtension === "csv") {
		const fileHandle = await fsPromises.open(outputPath, "w");
		try {
			await streamEvalCsv(evalRecord, {
				isRedteam: Boolean(evalRecord.config.redteam),
				write: async (data) => {
					await fileHandle.write(data);
				}
			});
		} finally {
			await fileHandle.close();
		}
	} else if (outputExtension === "json") await writeJsonOutputSafely(outputPath, evalRecord, shareableUrl);
	else if (outputExtension === "yaml" || outputExtension === "yml" || outputExtension === "txt") {
		const summary = await evalRecord.toEvaluateSummary();
		await fsPromises.writeFile(outputPath, yaml.dump({
			evalId: evalRecord.id,
			results: summary,
			config: evalRecord.config,
			shareableUrl,
			metadata
		}));
	} else if (outputExtension === "html") {
		const table = await evalRecord.getTable();
		invariant(table, "Table is required");
		const summary = await evalRecord.toEvaluateSummary();
		const template = await fsPromises.readFile(path$1.join(getDirectory(), "tableOutput.html"), "utf-8");
		const htmlTable = [[...table.head.vars, ...table.head.prompts.map((prompt) => `[${prompt.provider}] ${prompt.label}`)], ...table.body.map((row) => [...row.vars, ...row.outputs.map(outputToSimpleString)])];
		const htmlOutput = getNunjucksEngine().renderString(template, {
			config: evalRecord.config,
			table: htmlTable,
			results: summary
		});
		await fsPromises.writeFile(outputPath, htmlOutput);
	} else if (outputExtension === "jsonl") {
		await fsPromises.writeFile(outputPath, "");
		for await (const batchResults of evalRecord.fetchResultsBatched()) {
			const text = batchResults.map((result) => JSON.stringify(result)).join(os$1.EOL) + os$1.EOL;
			await fsPromises.appendFile(outputPath, text);
		}
	} else if (outputExtension === "xml") {
		const summary = await evalRecord.toEvaluateSummary();
		const sanitizeForXml = (obj) => {
			if (obj === null || obj === void 0) return "";
			if (typeof obj === "boolean" || typeof obj === "number") return String(obj);
			if (typeof obj === "string") return obj;
			if (Array.isArray(obj)) return obj.map(sanitizeForXml);
			if (typeof obj === "object") {
				const sanitized = {};
				for (const [key, value] of Object.entries(obj)) sanitized[key] = sanitizeForXml(value);
				return sanitized;
			}
			return String(obj);
		};
		const xmlData = new XMLBuilder({
			ignoreAttributes: false,
			format: true,
			indentBy: "  "
		}).build({ promptfoo: {
			evalId: evalRecord.id,
			results: sanitizeForXml(summary),
			config: sanitizeForXml(evalRecord.config),
			shareableUrl: shareableUrl || ""
		} });
		await fsPromises.writeFile(outputPath, xmlData);
	}
}
async function writeMultipleOutputs(outputPaths, evalRecord, shareableUrl) {
	await Promise.all(outputPaths.map((outputPath) => writeOutput(outputPath, evalRecord, shareableUrl)));
}

//#endregion
//#region src/util/runtime.ts
function printBorder() {
	const border = "=".repeat(TERMINAL_MAX_WIDTH);
	logger_default.info(border);
}

//#endregion
export { getTestCaseDeduplicationKey as A, extractVariablesFromTemplates as C, setupEnv as D, parseFileUrl as E, isGoogleProvider as F, isOpenAiProvider as I, isProviderAllowed as L, doesProviderRefMatch as M, getProviderDescription as N, deduplicateTestCases as O, isAnthropicProvider as P, extractVariablesFromTemplate as S, loadFunction as T, parsePathOrGlob as _, ComparisonEvalNotFoundError as a, renderEnvOnlyInObject as b, mergeComparisonTables as c, getResolvedRelativePath as d, maybeLoadConfigFromExternalFile as f, maybeLoadToolsFromExternalFile as g, maybeLoadResponseFormatFromExternalFile as h, writeOutput as i, resultIsForTestCase as j, filterRuntimeVars as k, fetchCsvFromGoogleSheet as l, maybeLoadFromExternalFileWithVars as m, createOutputMetadata as n, evalTableToJson as o, maybeLoadFromExternalFile as p, writeMultipleOutputs as r, generateEvalCsv as s, printBorder as t, getNunjucksEngineForFilePath as u, readFilters as v, getNunjucksEngine as w, renderVarsInObject as x, readOutput as y };
//# sourceMappingURL=util-CyzW5ayt.js.map