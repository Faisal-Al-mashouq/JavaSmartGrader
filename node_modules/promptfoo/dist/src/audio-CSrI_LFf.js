import "./chunk-FhC4c-0y.js";
import { b as getEnvString, i as logger_default } from "./logger-q5I8CByj.js";
import { p as REQUEST_TIMEOUT_MS } from "./fetch-BIPrzD39.js";
import { a as fetchWithCache } from "./cache-CMvgAnSi.js";

//#region src/providers/hyperbolic/audio.ts
const HYPERBOLIC_AUDIO_MODELS = [{
	id: "Melo-TTS",
	aliases: ["melo-tts", "melo"],
	cost: .001
}];
var HyperbolicAudioProvider = class {
	modelName;
	config;
	env;
	constructor(modelName, options = {}) {
		this.modelName = modelName || "Melo-TTS";
		this.config = options.config || {};
		this.env = options.env;
	}
	getApiKey() {
		if (this.config?.apiKey) return this.config.apiKey;
		return this.env?.HYPERBOLIC_API_KEY || getEnvString("HYPERBOLIC_API_KEY");
	}
	getApiUrl() {
		return this.config?.apiBaseUrl || "https://api.hyperbolic.xyz/v1";
	}
	id() {
		return `hyperbolic:audio:${this.modelName}`;
	}
	toString() {
		return `[Hyperbolic Audio Provider ${this.modelName}]`;
	}
	getApiModelName() {
		return HYPERBOLIC_AUDIO_MODELS.find((m) => m.id === this.modelName || m.aliases && m.aliases.includes(this.modelName))?.id || this.modelName;
	}
	calculateAudioCost(textLength) {
		const costPer1000Chars = HYPERBOLIC_AUDIO_MODELS.find((m) => m.id === this.modelName || m.aliases && m.aliases.includes(this.modelName))?.cost || .001;
		return textLength / 1e3 * costPer1000Chars;
	}
	async callApi(prompt, context, _callApiOptions) {
		const apiKey = this.getApiKey();
		if (!apiKey) throw new Error("Hyperbolic API key is not set. Set the HYPERBOLIC_API_KEY environment variable or add `apiKey` to the provider config.");
		const config = {
			...this.config,
			...context?.prompt?.config
		};
		const endpoint = "/audio/generation";
		const body = { text: prompt };
		if (config.model) body.model = config.model;
		if (config.voice) body.voice = config.voice;
		if (config.speed !== void 0) body.speed = config.speed;
		if (config.language) body.language = config.language;
		const headers = {
			"Content-Type": "application/json",
			Authorization: `Bearer ${apiKey}`
		};
		let data, status, statusText, latencyMs;
		let cached = false;
		try {
			({data, cached, status, statusText, latencyMs} = await fetchWithCache(`${this.getApiUrl()}${endpoint}`, {
				method: "POST",
				headers,
				body: JSON.stringify(body)
			}, REQUEST_TIMEOUT_MS));
			if (status < 200 || status >= 300) return { error: `API error: ${status} ${statusText}\n${typeof data === "string" ? data : JSON.stringify(data)}` };
		} catch (err) {
			logger_default.error(`API call error: ${String(err)}`);
			return { error: `API call error: ${String(err)}` };
		}
		if (data.error) return { error: typeof data.error === "string" ? data.error : JSON.stringify(data.error) };
		try {
			if (!data.audio) return { error: "No audio data returned from API" };
			const cost = cached ? 0 : this.calculateAudioCost(prompt.length);
			return {
				output: data.audio,
				cached,
				latencyMs,
				cost,
				...data.audio ? {
					isBase64: true,
					audio: {
						data: data.audio,
						format: "wav"
					}
				} : {}
			};
		} catch (err) {
			return { error: `API error: ${String(err)}: ${JSON.stringify(data)}` };
		}
	}
};
function createHyperbolicAudioProvider(providerPath, options = {}) {
	return new HyperbolicAudioProvider(providerPath.split(":").slice(2).join(":") || "Melo-TTS", options);
}

//#endregion
export { createHyperbolicAudioProvider };
//# sourceMappingURL=audio-CSrI_LFf.js.map