#!/usr/bin/env node
import { o as logger_default } from "./logger-Bzi5o47S.js";
import { WebClient } from "@slack/web-api";

//#region src/providers/slack.ts
var SlackProvider = class {
	client;
	options;
	constructor(options = {}) {
		this.options = options;
		const token = options.config?.token || process.env.SLACK_BOT_TOKEN;
		if (!token) throw new Error("Slack provider requires a token. Set SLACK_BOT_TOKEN or provide it in config.");
		if (!options.config?.channel) throw new Error("Slack provider requires a channel ID");
		this.client = new WebClient(token);
	}
	id() {
		return this.options.id || "slack";
	}
	async callApi(prompt, _context, _options) {
		const config = this.options.config;
		const channel = config.channel;
		const timeout = config.timeout || 6e4;
		const responseStrategy = config.responseStrategy || "first";
		try {
			const messageText = config.formatMessage ? config.formatMessage(prompt) : prompt;
			const startTime = Date.now();
			const postResult = await this.client.chat.postMessage({
				channel,
				text: messageText,
				thread_ts: config.threadTs,
				mrkdwn: true
			});
			if (!postResult.ok || !postResult.ts) throw new Error("Failed to post message to Slack");
			const messageTs = postResult.ts;
			let responseText;
			const responseMetadata = {
				messageTs,
				channel
			};
			switch (responseStrategy) {
				case "timeout":
					responseText = await this.collectResponsesUntilTimeout(channel, messageTs, timeout);
					break;
				case "user":
					if (!config.waitForUser) throw new Error("waitForUser must be specified when using \"user\" response strategy");
					responseText = await this.waitForUserResponse(channel, messageTs, config.waitForUser, timeout);
					responseMetadata.waitForUser = config.waitForUser;
					break;
				default:
					responseText = await this.waitForFirstResponse(channel, messageTs, timeout);
					break;
			}
			if (config.includeThread) responseMetadata.threadTs = messageTs;
			responseMetadata.responseTime = Date.now() - startTime;
			return {
				output: responseText,
				metadata: responseMetadata
			};
		} catch (error) {
			logger_default.error(`Slack provider error: ${error}`);
			if (error?.data?.error) {
				const slackError = error.data.error;
				switch (slackError) {
					case "channel_not_found": return { error: `Channel ${channel} not found. Please check the channel ID.` };
					case "not_in_channel": return { error: `Bot is not in channel ${channel}. Please invite the bot first.` };
					case "missing_scope": return { error: "Bot token is missing required scopes. Please check permissions." };
					case "ratelimited": return { error: "Slack API rate limit exceeded. Please try again later." };
					default: return { error: `Slack API error: ${slackError}` };
				}
			}
			return { error: error instanceof Error ? error.message : "Unknown error" };
		}
	}
	async waitForFirstResponse(channel, afterTs, timeout) {
		const startTime = Date.now();
		while (Date.now() - startTime < timeout) try {
			const result = await this.client.conversations.history({
				channel,
				oldest: afterTs,
				limit: 10
			});
			if (result.messages && result.messages.length > 0) {
				const response = result.messages.filter((msg) => msg.ts !== afterTs && msg.type === "message" && !msg.bot_id).sort((a, b) => parseFloat(a.ts || "0") - parseFloat(b.ts || "0"))[0];
				if (response && response.text) return response.text;
			}
			await new Promise((resolve) => setTimeout(resolve, 1e3));
		} catch (error) {
			logger_default.error(`Error fetching Slack messages: ${error}`);
			throw error;
		}
		throw new Error(`Timeout waiting for Slack response after ${timeout}ms`);
	}
	async waitForUserResponse(channel, afterTs, userId, timeout) {
		const startTime = Date.now();
		while (Date.now() - startTime < timeout) try {
			const result = await this.client.conversations.history({
				channel,
				oldest: afterTs,
				limit: 20
			});
			if (result.messages && result.messages.length > 0) {
				const response = result.messages.filter((msg) => msg.ts !== afterTs && msg.type === "message" && msg.user === userId).sort((a, b) => parseFloat(a.ts || "0") - parseFloat(b.ts || "0"))[0];
				if (response && response.text) return response.text;
			}
			await new Promise((resolve) => setTimeout(resolve, 1e3));
		} catch (error) {
			logger_default.error(`Error fetching Slack messages: ${error}`);
			throw error;
		}
		throw new Error(`Timeout waiting for response from user ${userId} after ${timeout}ms`);
	}
	async collectResponsesUntilTimeout(channel, afterTs, timeout) {
		const startTime = Date.now();
		const responses = [];
		const seenTimestamps = new Set([afterTs]);
		while (Date.now() - startTime < timeout) try {
			const result = await this.client.conversations.history({
				channel,
				oldest: afterTs,
				limit: 50
			});
			if (result.messages && result.messages.length > 0) result.messages.filter((msg) => !seenTimestamps.has(msg.ts || "") && msg.type === "message" && !msg.bot_id).sort((a, b) => parseFloat(a.ts || "0") - parseFloat(b.ts || "0")).forEach((msg) => {
				if (msg.ts) seenTimestamps.add(msg.ts);
				if (msg.text) responses.push(msg.text);
			});
			await new Promise((resolve) => setTimeout(resolve, 1e3));
		} catch (error) {
			logger_default.error(`Error fetching Slack messages: ${error}`);
			throw error;
		}
		return responses.join("\n\n");
	}
};

//#endregion
export { SlackProvider };
//# sourceMappingURL=slack-Ba3gil_6.js.map