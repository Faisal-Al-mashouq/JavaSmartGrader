const require_logger = require('./logger-CMp-NS-e.cjs');
const require_invariant = require('./invariant-CKcJAQ6M.cjs');
require('./esm-gWVPXn3r.cjs');
require('./pythonUtils-rOCm9w_5.cjs');
require('./types-DY--pQrH.cjs');
require('./util-BNInkV3p.cjs');
require('./fetch-ZkfbmPN0.cjs');
require('./cache-DH-n6i0J.cjs');
require('./genaiTracer-zK0Mtd_D.cjs');
const require_chat = require('./chat-CAz560qk.cjs');
require('./transform-CGHhgwFQ.cjs');
const require_messages = require('./messages-BbRLnkcl.cjs');
require('./util-YP1N9HUu.cjs');
require('./openai-eZz8QsxY.cjs');
require('./util-CHAqsUj1.cjs');

//#region src/providers/cloudflare-gateway.ts
/**
* Cloudflare AI Gateway Provider
*
* Routes requests to AI providers (OpenAI, Anthropic, etc.) through Cloudflare AI Gateway.
* Provides caching, rate limiting, analytics, and cost tracking.
*
* Gateway URL format: https://gateway.ai.cloudflare.com/v1/{account_id}/{gateway_id}/{provider}
*
* Usage:
*   cloudflare-gateway:openai:gpt-4o
*   cloudflare-gateway:anthropic:claude-sonnet-4-20250514
*   cloudflare-gateway:groq:llama-3.3-70b-versatile
*
* @see https://developers.cloudflare.com/ai-gateway/
*/
const CLOUDFLARE_GATEWAY_BASE_URL = "https://gateway.ai.cloudflare.com/v1";
/**
* Supported provider configurations for Cloudflare AI Gateway
*
* Note: Some providers have special URL requirements:
* - azure-openai: Requires resourceName and deploymentName in config
* - workers-ai: Model name is appended to URL path
*
* AWS Bedrock is NOT supported because it requires AWS request signing
* which is incompatible with the gateway proxy approach.
*/
const PROVIDER_CONFIGS = {
	openai: { apiKeyEnvar: "OPENAI_API_KEY" },
	anthropic: { apiKeyEnvar: "ANTHROPIC_API_KEY" },
	groq: { apiKeyEnvar: "GROQ_API_KEY" },
	"perplexity-ai": { apiKeyEnvar: "PERPLEXITY_API_KEY" },
	"google-ai-studio": { apiKeyEnvar: "GOOGLE_API_KEY" },
	mistral: { apiKeyEnvar: "MISTRAL_API_KEY" },
	cohere: { apiKeyEnvar: "COHERE_API_KEY" },
	"azure-openai": { apiKeyEnvar: "AZURE_OPENAI_API_KEY" },
	"workers-ai": { apiKeyEnvar: "CLOUDFLARE_API_KEY" },
	huggingface: { apiKeyEnvar: "HUGGINGFACE_API_KEY" },
	replicate: { apiKeyEnvar: "REPLICATE_API_KEY" },
	grok: { apiKeyEnvar: "XAI_API_KEY" }
};
/**
* Get a custom environment variable value safely
* Uses process.env directly for arbitrary env var names to avoid type casting issues
*/
function getCustomEnvValue(envVarName, env) {
	const envOverrideValue = env?.[envVarName];
	if (envOverrideValue) return envOverrideValue;
	return process.env[envVarName];
}
/**
* Get the Cloudflare account ID from config or environment
*/
function getAccountId(config, env) {
	if (config?.accountId) return config.accountId;
	if (config?.accountIdEnvar) {
		const customValue = getCustomEnvValue(config.accountIdEnvar, env);
		if (customValue) return customValue;
		require_logger.logger_default.warn(`[CloudflareGateway] Custom account ID environment variable '${config.accountIdEnvar}' is not set. Falling back to CLOUDFLARE_ACCOUNT_ID.`);
	}
	const accountIdCandidate = env?.CLOUDFLARE_ACCOUNT_ID || require_logger.getEnvString("CLOUDFLARE_ACCOUNT_ID");
	require_invariant.invariant(accountIdCandidate, "Cloudflare account ID required. Supply it via config accountId or accountIdEnvar, or the CLOUDFLARE_ACCOUNT_ID environment variable");
	return accountIdCandidate;
}
/**
* Get the Cloudflare AI Gateway ID from config or environment
*/
function getGatewayId(config, env) {
	if (config?.gatewayId) return config.gatewayId;
	if (config?.gatewayIdEnvar) {
		const customValue = getCustomEnvValue(config.gatewayIdEnvar, env);
		if (customValue) return customValue;
		require_logger.logger_default.warn(`[CloudflareGateway] Custom gateway ID environment variable '${config.gatewayIdEnvar}' is not set. Falling back to CLOUDFLARE_GATEWAY_ID.`);
	}
	const gatewayIdCandidate = env?.CLOUDFLARE_GATEWAY_ID || require_logger.getEnvString("CLOUDFLARE_GATEWAY_ID");
	require_invariant.invariant(gatewayIdCandidate, "Cloudflare AI Gateway ID required. Supply it via config gatewayId or gatewayIdEnvar, or the CLOUDFLARE_GATEWAY_ID environment variable");
	return gatewayIdCandidate;
}
/**
* Get the optional Cloudflare AI Gateway authentication token
*/
function getCfAigToken(config, env) {
	if (config?.cfAigToken) return config.cfAigToken;
	if (config?.cfAigTokenEnvar) {
		const customValue = getCustomEnvValue(config.cfAigTokenEnvar, env);
		if (customValue) return customValue;
	}
	return env?.CF_AIG_TOKEN || require_logger.getEnvString("CF_AIG_TOKEN");
}
/**
* Build the Cloudflare AI Gateway URL for a specific provider
*
* Most providers use: https://gateway.ai.cloudflare.com/v1/{account_id}/{gateway_id}/{provider}
* Azure OpenAI uses: https://gateway.ai.cloudflare.com/v1/{account_id}/{gateway_id}/azure-openai/{resource_name}/{deployment_name}
* Workers AI uses: https://gateway.ai.cloudflare.com/v1/{account_id}/{gateway_id}/workers-ai/{model_id}
*/
function buildGatewayUrl(accountId, gatewayId, provider, config, modelName) {
	const baseUrl = `${CLOUDFLARE_GATEWAY_BASE_URL}/${accountId}/${gatewayId}`;
	if (provider === "azure-openai") {
		const resourceName = config?.resourceName;
		const deploymentName = config?.deploymentName;
		require_invariant.invariant(resourceName, "Azure OpenAI requires resourceName in config. Example: cloudflare-gateway:azure-openai:gpt-4 with config.resourceName set");
		require_invariant.invariant(deploymentName, "Azure OpenAI requires deploymentName in config. Example: cloudflare-gateway:azure-openai:gpt-4 with config.deploymentName set");
		return `${baseUrl}/azure-openai/${resourceName}/${deploymentName}`;
	}
	if (provider === "workers-ai") {
		require_invariant.invariant(modelName, "Workers AI requires a model name (e.g., @cf/meta/llama-3.1-8b-instruct)");
		return `${baseUrl}/workers-ai/${modelName}`;
	}
	return `${baseUrl}/${provider}`;
}
/**
* Extract Cloudflare-specific config keys that shouldn't be passed to the underlying provider
*/
function getPassthroughConfig(config) {
	const { accountId: _accountId, accountIdEnvar: _accountIdEnvar, gatewayId: _gatewayId, gatewayIdEnvar: _gatewayIdEnvar, cfAigToken: _cfAigToken, cfAigTokenEnvar: _cfAigTokenEnvar, resourceName: _resourceName, deploymentName: _deploymentName, apiVersion: _apiVersion, ...passthrough } = config || {};
	return passthrough;
}
/**
* Cloudflare AI Gateway provider for OpenAI-compatible APIs
*
* Routes requests to OpenAI, Groq, Perplexity, Mistral, etc. through Cloudflare AI Gateway
*/
var CloudflareGatewayOpenAiProvider = class extends require_chat.OpenAiChatCompletionProvider {
	underlyingProvider;
	constructor(underlyingProvider, modelName, providerOptions) {
		const gatewayUrl = buildGatewayUrl(getAccountId(providerOptions.config, providerOptions.env), getGatewayId(providerOptions.config, providerOptions.env), underlyingProvider, providerOptions.config, modelName);
		const passthrough = getPassthroughConfig(providerOptions.config);
		const providerConfig = PROVIDER_CONFIGS[underlyingProvider];
		const cfAigToken = getCfAigToken(providerOptions.config, providerOptions.env);
		const headers = { ...providerOptions.config?.headers || {} };
		if (cfAigToken) headers["cf-aig-authorization"] = `Bearer ${cfAigToken}`;
		let finalGatewayUrl = gatewayUrl;
		let apiKeyEnvar;
		if (underlyingProvider === "azure-openai") {
			const azureApiKey = providerOptions.config?.apiKey || require_logger.getEnvString("AZURE_OPENAI_API_KEY");
			require_invariant.invariant(azureApiKey, "Azure OpenAI API key is required. Set the AZURE_OPENAI_API_KEY environment variable or add apiKey to the provider config.");
			headers["api-key"] = azureApiKey;
			apiKeyEnvar = void 0;
			finalGatewayUrl = `${gatewayUrl}?api-version=${providerOptions.config?.apiVersion || "2024-12-01-preview"}`;
		} else apiKeyEnvar = providerOptions.config?.apiKeyEnvar || providerConfig?.apiKeyEnvar;
		const config = {
			...passthrough,
			apiKeyEnvar,
			apiBaseUrl: finalGatewayUrl,
			headers: Object.keys(headers).length > 0 ? headers : void 0
		};
		super(modelName, {
			...providerOptions,
			config
		});
		this.underlyingProvider = underlyingProvider;
		require_logger.logger_default.debug(`[CloudflareGateway] Configured ${underlyingProvider}:${modelName}`, {
			gatewayUrl: finalGatewayUrl,
			hasApiKey: !!providerOptions.config?.apiKey,
			hasCfAigToken: !!cfAigToken
		});
	}
	id() {
		return `cloudflare-gateway:${this.underlyingProvider}:${this.modelName}`;
	}
	toString() {
		return `[Cloudflare AI Gateway ${this.underlyingProvider} Provider ${this.modelName}]`;
	}
	toJSON() {
		return {
			provider: "cloudflare-gateway",
			underlyingProvider: this.underlyingProvider,
			model: this.modelName,
			config: {
				...this.config,
				apiKey: void 0
			}
		};
	}
};
/**
* Extract Anthropic-compatible options from the gateway config
*/
function getAnthropicPassthroughConfig(config) {
	if (!config) return {};
	const { apiKey, max_tokens, temperature, top_p, cost } = config;
	const top_k = config.top_k;
	return {
		...apiKey !== void 0 && { apiKey },
		...max_tokens !== void 0 && { max_tokens },
		...temperature !== void 0 && { temperature },
		...top_p !== void 0 && { top_p },
		...top_k !== void 0 && { top_k },
		...cost !== void 0 && { cost }
	};
}
/**
* Cloudflare AI Gateway provider for Anthropic
*
* Routes requests to Anthropic through Cloudflare AI Gateway
*/
var CloudflareGatewayAnthropicProvider = class extends require_messages.AnthropicMessagesProvider {
	constructor(modelName, providerOptions) {
		const gatewayUrl = buildGatewayUrl(getAccountId(providerOptions.config, providerOptions.env), getGatewayId(providerOptions.config, providerOptions.env), "anthropic");
		const passthrough = getAnthropicPassthroughConfig(providerOptions.config);
		const cfAigToken = getCfAigToken(providerOptions.config, providerOptions.env);
		const headers = { ...providerOptions.config?.headers || {} };
		if (cfAigToken) headers["cf-aig-authorization"] = `Bearer ${cfAigToken}`;
		const config = {
			...passthrough,
			apiBaseUrl: gatewayUrl,
			headers: Object.keys(headers).length > 0 ? headers : void 0
		};
		super(modelName, {
			...providerOptions,
			config
		});
		require_logger.logger_default.debug(`[CloudflareGateway] Configured anthropic:${modelName}`, {
			gatewayUrl,
			hasApiKey: !!providerOptions.config?.apiKey,
			hasCfAigToken: !!cfAigToken
		});
	}
	id() {
		return `cloudflare-gateway:anthropic:${this.modelName}`;
	}
	toString() {
		return `[Cloudflare AI Gateway Anthropic Provider ${this.modelName}]`;
	}
	toJSON() {
		return {
			provider: "cloudflare-gateway",
			underlyingProvider: "anthropic",
			model: this.modelName,
			config: {
				...this.config,
				apiKey: void 0
			}
		};
	}
};
/**
* Create a Cloudflare AI Gateway provider from a provider path
*
* @param providerPath - Provider path in format cloudflare-gateway:{provider}:{model}
* @param options - Provider options including config and environment
* @returns Configured provider instance
*
* @example
* ```yaml
* providers:
*   - id: cloudflare-gateway:openai:gpt-4o
*     config:
*       accountId: ${CLOUDFLARE_ACCOUNT_ID}
*       gatewayId: ${CLOUDFLARE_GATEWAY_ID}
*       temperature: 0.7
* ```
*/
function createCloudflareGatewayProvider(providerPath, options = {}) {
	const splits = providerPath.split(":");
	if (splits.length < 3) throw new Error(`Invalid cloudflare-gateway provider path: "${providerPath}". Expected format: cloudflare-gateway:{provider}:{model} (e.g., cloudflare-gateway:openai:gpt-4o)`);
	const underlyingProvider = splits[1];
	const modelName = splits.slice(2).join(":");
	require_invariant.invariant(modelName, "Model name is required for cloudflare-gateway provider");
	if (!PROVIDER_CONFIGS[underlyingProvider]) throw new Error(`Unsupported Cloudflare AI Gateway provider: "${underlyingProvider}". Supported providers: ${Object.keys(PROVIDER_CONFIGS).join(", ")}`);
	if (underlyingProvider === "anthropic") return new CloudflareGatewayAnthropicProvider(modelName, options);
	return new CloudflareGatewayOpenAiProvider(underlyingProvider, modelName, options);
}

//#endregion
exports.createCloudflareGatewayProvider = createCloudflareGatewayProvider;
//# sourceMappingURL=cloudflare-gateway-BmW0gnqL.cjs.map