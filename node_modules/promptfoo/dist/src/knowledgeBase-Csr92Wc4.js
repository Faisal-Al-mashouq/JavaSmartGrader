#!/usr/bin/env node
import "./chunk-DHDDz29n.js";
import { C as getEnvString, S as getEnvInt, o as logger_default } from "./logger-Bzi5o47S.js";
import "./fetch-TcCC0nEJ.js";
import "./accounts-CjU7QSnv.js";
import "./cloud-UwfmA0Ne.js";
import { r as telemetry_default } from "./telemetry-CB8ltkOD.js";
import { o as getCache, s as isCacheEnabled } from "./cache-xb4oZe27.js";
import { a as createEmptyTokenUsage } from "./tokenUsageUtils-C9fIWtvn.js";
import { t as AwsBedrockGenericProvider } from "./base-d8hHSpEx.js";

//#region src/providers/bedrock/knowledgeBase.ts
/**
* AWS Bedrock Knowledge Base provider for RAG (Retrieval Augmented Generation).
* Allows querying an existing AWS Bedrock Knowledge Base with text queries.
*/
var AwsBedrockKnowledgeBaseProvider = class extends AwsBedrockGenericProvider {
	knowledgeBaseClient;
	kbConfig;
	constructor(modelName, options = {}) {
		super(modelName, options);
		if (!options.config?.knowledgeBaseId) throw new Error("Knowledge Base ID is required. Please provide a knowledgeBaseId in the provider config.");
		this.kbConfig = options.config || { knowledgeBaseId: "" };
		telemetry_default.record("feature_used", {
			feature: "knowledge_base",
			provider: "bedrock"
		});
	}
	id() {
		return `bedrock:kb:${this.kbConfig.knowledgeBaseId}`;
	}
	toString() {
		return `[Amazon Bedrock Knowledge Base Provider ${this.kbConfig.knowledgeBaseId}]`;
	}
	async getKnowledgeBaseClient() {
		if (!this.knowledgeBaseClient) {
			let handler;
			const apiKey = this.getApiKey();
			if (getEnvString("HTTP_PROXY") || getEnvString("HTTPS_PROXY") || apiKey) try {
				const { NodeHttpHandler } = await import("@smithy/node-http-handler");
				const { ProxyAgent } = await import("proxy-agent");
				const proxyAgent = getEnvString("HTTP_PROXY") || getEnvString("HTTPS_PROXY") ? new ProxyAgent() : void 0;
				handler = new NodeHttpHandler({
					...proxyAgent ? { httpsAgent: proxyAgent } : {},
					requestTimeout: 3e5
				});
				if (apiKey) {
					const originalHandle = handler.handle.bind(handler);
					handler.handle = async (request, options) => {
						request.headers = {
							...request.headers,
							Authorization: `Bearer ${apiKey}`
						};
						return originalHandle(request, options);
					};
				}
			} catch {
				const reason = apiKey ? "API key authentication requires the @smithy/node-http-handler package" : "Proxy configuration requires the @smithy/node-http-handler package";
				throw new Error(`${reason}. Please install it in your project or globally.`);
			}
			try {
				const { BedrockAgentRuntimeClient } = await import("@aws-sdk/client-bedrock-agent-runtime");
				const credentials = await this.getCredentials();
				this.knowledgeBaseClient = new BedrockAgentRuntimeClient({
					region: this.getRegion(),
					maxAttempts: getEnvInt("AWS_BEDROCK_MAX_RETRIES", 10),
					retryMode: "adaptive",
					...credentials ? { credentials } : {},
					...handler ? { requestHandler: handler } : {}
				});
			} catch (err) {
				throw new Error(`The @aws-sdk/client-bedrock-agent-runtime package is required as a peer dependency. Please install it in your project or globally. Error: ${err}`);
			}
		}
		return this.knowledgeBaseClient;
	}
	async callApi(prompt) {
		const client = await this.getKnowledgeBaseClient();
		let modelArn = this.kbConfig.modelArn;
		if (!modelArn) if (this.modelName.includes("arn:aws:bedrock")) modelArn = this.modelName;
		else if (this.modelName.startsWith("us.") || this.modelName.startsWith("eu.") || this.modelName.startsWith("apac.")) modelArn = this.modelName;
		else modelArn = `arn:aws:bedrock:${this.getRegion()}::foundation-model/${this.modelName}`;
		const knowledgeBaseConfiguration = { knowledgeBaseId: this.kbConfig.knowledgeBaseId };
		if (this.kbConfig.modelArn || this.modelName !== "default") knowledgeBaseConfiguration.modelArn = modelArn;
		if (this.kbConfig.numberOfResults !== void 0) knowledgeBaseConfiguration.retrievalConfiguration = { vectorSearchConfiguration: { numberOfResults: this.kbConfig.numberOfResults } };
		const params = {
			input: { text: prompt },
			retrieveAndGenerateConfiguration: {
				type: "KNOWLEDGE_BASE",
				knowledgeBaseConfiguration
			}
		};
		logger_default.debug("Calling Amazon Bedrock Knowledge Base API", { params });
		const cache = await getCache();
		const sensitiveKeys = [
			"accessKeyId",
			"secretAccessKey",
			"sessionToken"
		];
		const cacheConfig = {
			region: this.getRegion(),
			modelName: this.modelName,
			...Object.fromEntries(Object.entries(this.kbConfig).filter(([key]) => !sensitiveKeys.includes(key)))
		};
		const configStr = JSON.stringify(cacheConfig, Object.keys(cacheConfig).sort());
		const cacheKey = `bedrock-kb:${Buffer.from(configStr).toString("base64")}:${prompt}`;
		if (isCacheEnabled()) {
			const cachedResponse = await cache.get(cacheKey);
			if (cachedResponse) {
				logger_default.debug(`Returning cached response for ${prompt}`);
				const parsedResponse = JSON.parse(cachedResponse);
				return {
					output: parsedResponse.output,
					metadata: { citations: parsedResponse.citations },
					tokenUsage: createEmptyTokenUsage(),
					cached: true
				};
			}
		}
		try {
			const { RetrieveAndGenerateCommand } = await import("@aws-sdk/client-bedrock-agent-runtime");
			const command = new RetrieveAndGenerateCommand(params);
			const response = await client.send(command);
			logger_default.debug("Amazon Bedrock Knowledge Base API response", { response });
			let output = "";
			if (response && response.output && response.output.text) output = response.output.text;
			let citations = [];
			if (response && response.citations && Array.isArray(response.citations)) citations = response.citations;
			if (isCacheEnabled()) try {
				await cache.set(cacheKey, JSON.stringify({
					output,
					citations
				}));
			} catch (err) {
				logger_default.error(`Failed to cache knowledge base response: ${String(err)}`);
			}
			return {
				output,
				metadata: { citations },
				tokenUsage: createEmptyTokenUsage()
			};
		} catch (err) {
			return { error: `Bedrock Knowledge Base API error: ${String(err)}` };
		}
	}
};

//#endregion
export { AwsBedrockKnowledgeBaseProvider };
//# sourceMappingURL=knowledgeBase-Csr92Wc4.js.map